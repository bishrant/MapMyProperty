{"version":3,"sources":["webpack/bootstrap","./node_modules/@arcgis/webpack-plugin/loader/dojo.js"],"names":[],"mappings":";QAAA;QACA;QACA;QACA;QACA;;QAEA;QACA;QACA;QACA,QAAQ,oBAAoB;QAC5B;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA,iBAAiB,4BAA4B;QAC7C;QACA;QACA,kBAAkB,2BAA2B;QAC7C;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;;QAEA;;QAEA;QACA;QACA,yCAAyC,kBAAkB;QAC3D;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;QAEA;QACA;QACA;QACA;;;QAGA;;QAEA;QACA,iCAAiC;;QAEjC;QACA;QACA;QACA,KAAK;QACL;QACA;QACA;QACA,MAAM;QACN;;QAEA;QACA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,wBAAwB,kCAAkC;QAC1D,MAAM;QACN;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;QAEA;QACA,0CAA0C,oBAAoB,WAAW;;QAEzE;QACA;QACA;QACA;QACA,gBAAgB,uBAAuB;QACvC;;;QAGA,eAAe;QACf,6BAA6B;QAC7B;QACA;QACA;;QAEA;QACA;QACA;;QAEA;QACA;QACA;;QAEA;QACA;QACA;QACA;;QAEA,6CAA6C;QAC7C;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,qCAAqC,cAAc;QACnD;QACA;QACA,wCAAwC,cAAc;QACtD;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA,uCAAuC;QACvC;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA,gDAAgD;QAChD;QACA;QACA;;QAEA;QACA,gDAAgD,YAAY;QAC5D;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA,kDAAkD,qBAAqB;QACvE,MAAM;QACN;QACA;QACA;QACA;QACA;QACA,OAAO;QACP;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA,yDAAyD;QACzD,mBAAmB;QACnB;QACA;QACA;QACA;QACA;QACA,uBAAuB,+BAA+B;QACtD,4BAA4B,+BAA+B;QAC3D;QACA;QACA,MAAM;QACN;QACA;;QAEA,+DAA+D;QAC/D,mBAAmB;QACnB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,MAAM;QACN;QACA;QACA;QACA;QACA;QACA;QACA;QACA,QAAQ;QACR,qBAAqB,mBAAmB;QACxC;QACA,OAAO;QACP;QACA;QACA,gDAAgD;QAChD,iEAAiE;QACjE,qDAAqD;QACrD,UAAU,iCAAiC,oBAAoB;QAC/D,SAAS;QACT;QACA;QACA;QACA,OAAO;QACP;QACA;QACA;QACA;QACA;QACA;QACA,MAAM;QACN;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAI;;QAEJ;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,sBAAsB;QACtB;QACA;QACA,gDAAgD,4BAA4B,2DAA2D,IAAI,8CAA8C,IAAI,yDAAyD,IAAI,oEAAoE,IAAI,mDAAmD,IAAI,gEAAgE,IAAI,4CAA4C,IAAI,8CAA8C,IAAI,8CAA8C,IAAI,qDAAqD,IAAI,sFAAsF;QAChuB;QACA;QACA;QACA;QACA;QACA,cAAc,EAAE,EAAE,IAAI,sIAAsI;QAC5J;QACA;QACA;QACA,cAAc,EAAE,EAAE,IAAI,kGAAkG;QACxH;QACA;QACA;QACA,cAAc,EAAE,EAAE,WAAW,cAAc,oKAAoK,EAAE,uBAAuB,uGAAuG,EAAE;QACjV,yBAAyB,aAAa,+LAA+L,EAAE;QACvO;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,OAAO;QACP;QACA;QACA;QACA;QACA;QACA,IAAI;QACJ;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,MAAM;QACN;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,uEAAuE,sCAAsC;QAC7G,GAAG,IAAI;;QAEP;QACA;;;;;;;;;;;;ACvcA,sEAAsE,+BAA+B;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,eAAe;;AAEf;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,iCAAiC,4BAA4B;AAC7D,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,2EAA2E;AAC3E;;AAEA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,OAAO,KAE4F;AACnG,QAAQ,EAKN;;AAEF,OAAO,KAEyF;AAChG,QAAQ,mCAWN;;AAEF,OAAO,KAA8G;AACrH,QAAQ,EA4BN;;AAEF,0DAA0D;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,EAON;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAoGN;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,EAAE,SAA0C;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B,gFAAgF;AAChF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA,2DAA2D;AAC3D,OAAO;;AAEP;AACA,8BAA8B;AAC9B,OAAO;;AAEP;AACA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA,kCAAkC,oEAAoE;AACtG;AACA;AACA;AACA,mEAAmE;AACnE,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,MAAM,KAAG,GAAG,kCAuBT;AACH;AACA,gCAAgC,iCAAiC,iBAAiB,EAAE;AACpF,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB,EAAE;AAC3D;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,uBAAuB,YAAY;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA,mFAAmF;AACnF;AACA,uCAAuC;AACvC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAgB,CAAC,aAUpB;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,MAAM;AACN;;AAEA,iEAAiE;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA,QAAQ,KAAG,GAAG,eAiBT;AACL;AACA;;AAEA;AACA,gCAAgC;AAChC;;AAEA,MAAM,KAAQ,EAAE,gDAmCb;;AAEH,SAAS,YAQN;;AAEH,0BAA0B;AAC1B;AACA;;AAEA;AACA,SAAS,EAON;;AAEH;AACA;;AAEA,EAAE,IAAI,EAaJ;;;AAGF,KAAK,KAAG,GAAG,wKA+KT;;AAEF;AACA,kCAAkC,8BAA8B;AAChE;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA,UAAU,WAGN;AACJ,YAAY;AACZ;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI,YAAY,EAEZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,KAAK,KAAG,GAAG,sEAmDT;;AAEF;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;;AAEA,KAAK,KAAG,GAAG,6PA+MT;;AAEF;AACA,aAAa;AACb;AACA;;;;AAIA,QAAQ,EAQN;;AAEF,YAAY,0HAySV;;AAEF;AACA;AACA;AACA,QAAQ,EAgBN;;AAEF,UAAU,EASR;;AAEF,KAAK,KAAsB,CAAC,wDAsE1B;;AAEF,QAAQ,EAQN;AACF;AACA;;AAEA,QAAQ,cAwCN;AACF;AACA;AACA,KAAK,KAAG,GAAG,YAyFT;AACF;AACA;AACA,uEAAuE;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF,QAAQ,EAyBN;;AAEF,2CAA2C;AAC3C;AACA;AACA,SAAS,EAEN;AACH;AACA,EAAE;AACF;AACA;AACA,SAAS,EAEN;AACH;;AAEA,KAAK,KAAoC,CAAC,4BAMxC;;AAEF,KAAK,KAAS,EAAE,+BAKd;AACF,IAAI,KAAG,EAAE,EAGP;AACF,CAAC;AACD,yC","file":"runtime.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"runtime\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"\" + ({\"common\":\"common\"}[chunkId]||chunkId) + \".js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\t// create error before stack unwound to get useful stacktrace later\n \t\t\t\tvar error = new Error();\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n \t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tdocument.head.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t(function() { /* Start undefined extensions */\n \t\t\tfunction mix(dest, src) { // eslint-disable-line no-unused-vars\n \t\t\t\tfor(var n in src) dest[n] = src[n];\n \t\t\t\treturn dest;\n \t\t\t}\n\n \t\t\tfunction toUrl(name, referenceModule) {\n \t\t\t\treturn loaderScope.require.toUrl(name, referenceModule);\n \t\t\t}\n\n \t\t\tfunction toAbsMid(name, referenceModule) {\n \t\t\t\treturn loaderScope.require.toAbsMid(name, referenceModule);\n \t\t\t}\n\n \t\t\t// dojo require function.\n \t\t\tfunction req(config, dependencies, callback) {\n \t\t\t\treturn contextRequire(config, dependencies, callback, 0, req);\n \t\t\t};\n\n \t\t\tfunction createContextRequire(moduleId) { // eslint-disable-line no-unused-vars\n \t\t\t\tif (req.absMidsById[moduleId]) {\n \t\t\t\t\tmoduleId = req.absMidsById[moduleId];\n \t\t\t\t}\n \t\t\t\tif (!moduleId) return req;\n \t\t\t\tvar result = function(a1, a2, a3) {\n \t\t\t\t\treturn contextRequire(a1, a2, a3, moduleId, req);\n \t\t\t\t};\n \t\t\t\tfor (var p in req) {\n \t\t\t\t\tif (req.hasOwnProperty(p)) {\n \t\t\t\t\t\tresult[p] = req[p];\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tresult.toUrl = function(name) {\n \t\t\t\t\treturn toUrl(name, moduleId ? {mid: moduleId} : null);\n \t\t\t\t};\n \t\t\t\tresult.toAbsMid = function(name) {\n \t\t\t\t\treturn toAbsMid(name, moduleId ? {mid: moduleId} : null);\n \t\t\t\t};\n\n \t\t\t\tif (req.undef) {\n \t\t\t\t\tresult.undef = function(mid) {\n \t\t\t\t\t\treq.undef(mid, moduleId);\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\treturn result;\n \t\t\t}\n\n \t\t\tfunction registerAbsMids(absMids) { // eslint-disable-line no-unused-vars\n \t\t\t\tfor (var s in absMids) {\n \t\t\t\t\treq.absMids[s] = absMids[s];\n \t\t\t\t\tif (!req.absMidsById[absMids[s]]) {\n \t\t\t\t\t\treq.absMidsById[absMids[s]] = s;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n\n \t\t\tfunction resolveTernaryHasExpression(expr) { // eslint-disable-line no-unused-vars\n \t\t\t\t// Expects an expression of the form supported by dojo/has.js loader, except that module identifiers are\n \t\t\t\t// integers corresponding to webpack module ids.  Returns a module reference if evaluation of the expression\n \t\t\t\t// using the currently defined features returns a module id, or else undefined.\n\n \t\t\t\tvar has = findModule(\"dojo/has\", null, false);\n \t\t\t\tvar id = has.normalize(expr, function(arg){return arg;});\n \t\t\t\treturn id && __webpack_require__(id) || undefined;\n \t\t\t}\n\n \t\t\tfunction findModule(mid, referenceModule, noInstall, asModuleObj) {\n \t\t\t\tmid = mid.split(\"!\").map(function(segment) {\n \t\t\t\t\tvar isRelative = segment.charAt(0) === '.';\n \t\t\t\t\tif(isRelative && !referenceModule){\n \t\t\t\t\t\treturn segment;\n \t\t\t\t\t}\n \t\t\t\t\treturn toAbsMid(segment, referenceModule ? {mid: referenceModule} : null);\n \t\t\t\t}).join(\"!\");\n \t\t\t\tvar result;\n \t\t\t\tif (mid in req.absMids && __webpack_require__.m[req.absMids[mid]]) {\n \t\t\t\t\tif (noInstall) {\n \t\t\t\t\t\tvar module = installedModules[req.absMids[mid]];\n \t\t\t\t\t\tresult = module && module.l && (asModuleObj ? module : module.exports);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tresult = __webpack_require__(req.absMids[mid]);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (!result) {\n \t\t\t\t\tthrow new Error('Module not found: ' + mid);\n \t\t\t\t}\n \t\t\t\treturn result;\n \t\t\t}\n\n \t\t\tfunction dojoModuleFromWebpackModule(webpackModule) { // eslint-disable-line no-unused-vars\n \t\t\t\tvar result = {i:webpackModule.i};\n \t\t\t\tvar id = req.absMidsById[webpackModule.i];\n \t\t\t\tif (id) {\n \t\t\t\t\tresult.id = id;\n \t\t\t\t}\n \t\t\t\tObject.defineProperty(result, \"exports\", {\n \t\t\t\t\tget: function() { return webpackModule.exports;},\n \t\t\t\t\tset: function(value) {webpackModule.exports = value;},\n \t\t\t\t\tenumerable: true,\n \t\t\t\t\tconfigurable: true\n \t\t\t\t});\n \t\t\t\treturn result;\n \t\t\t}\n\n \t\t\tfunction contextRequire(a1, a2, a3, referenceModule, req) { // eslint-disable-line no-shadow\n \t\t\t\tvar type = ({}.toString).call(a1);\n \t\t\t\tif (type === '[object String]') {\n \t\t\t\t\t// a3 is passed by require calls injected into dependency arrays for dependencies specified\n \t\t\t\t\t// as identifiers (vs. string literals).\n \t\t\t\t\tvar noInstall = !(a3 === false);\n \t\t\t\t\tvar m = findModule(a1, referenceModule, noInstall);\n \t\t\t\t\tif (typeof m === 'object' && m.__DOJO_WEBPACK_DEFINE_PROMISE__) {\n \t\t\t\t\t\tthrow new Error('Module not found: ' + a1);\n \t\t\t\t\t}\n \t\t\t\t\treturn m;\n \t\t\t\t} else if (type === '[object Object]') {\n \t\t\t\t\tthrow new Error('Require config is not supported by WebPack');\n \t\t\t\t}\n \t\t\t\tif (type === '[object Array]') {\n \t\t\t\t\tvar modules = [], callback = a2, errors = [];\n \t\t\t\t\ta1.forEach(function (mid) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tmodules.push(findModule(mid, referenceModule));\n \t\t\t\t\t\t} catch (e) {\n \t\t\t\t\t\t\terrors.push({mid: mid, error: e});\n \t\t\t\t\t\t}\n \t\t\t\t\t});\n \t\t\t\t\tif (errors.length === 0) {\n \t\t\t\t\t\tif (callback) {\n \t\t\t\t\t\t\tif (false && isDefinePromise(modules)) { // eslint-disable-line no-undef\n \t\t\t\t\t\t\t\tPromise.all(wrapPromises(modules)).then(function(deps) { // eslint-disable-line no-undef\n \t\t\t\t\t\t\t\t\tcallback.apply(this, unwrapPromises(deps)); // eslint-disable-line no-undef\n \t\t\t\t\t\t\t\t}.bind(this)).catch(function(err){console.error(err);});\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tcallback.apply(this, modules);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\tvar error = new Error(\"findModules\");\n \t\t\t\t\t\terror.src = \"dojo-webpack-plugin\";\n \t\t\t\t\t\terror.info = errors;\n \t\t\t\t\t\treq.signal(\"error\", error);\n \t\t\t\t\t}\n \t\t\t\t\treturn req;\n \t\t\t\t} else {\n \t\t\t\t\tthrow new Error('Unsupported require call');\n \t\t\t\t}\n \t\t\t}\n \t\t\treq.toUrl = toUrl;\n \t\t\treq.toAbsMid = toAbsMid;\n \t\t\treq.absMids = {};\n \t\t\treq.absMidsById = [];\n \t\t\treq.async = 1;\n \t\tvar globalObj = this||window;\n \t\tregisterAbsMids({\n \t\t\t// \"/home/runner/work/MapMyProperty/MapMyProperty/node_modules/@arcgis/webpack-plugin/loader/dojo.js\" = \"./node_modules/@arcgis/webpack-plugin/loader/dojo.js\"\n \t\t});\n\n \t\tglobalObj.require = req;\n \t\t\t(this||window)[\"webpackJsonp\"].registerAbsMids = registerAbsMids;\n\n \t\t// expose the Dojo compatibility functions as a properties of __webpack_require__\n \t\tif (__webpack_require__.dj) throw new Error(\"__webpack_require__.dj name collision.\")\n \t\t__webpack_require__.dj = {\n \t\t\tr: req,\n \t\t\tc: createContextRequire,\n \t\t\tm: dojoModuleFromWebpackModule,\n \t\t\th: resolveTernaryHasExpression,\n \t\t};\n \t\tvar loaderScope = {document:globalObj.document};\n \t\tloaderScope.global = loaderScope.window = loaderScope;\n \t\tglobalObj.dojoConfig = globalObj.dojoConfig || {}\n \t\tvar userConfig = mix(globalObj.dojoConfig, ({'baseUrl':'.','packages':[({'name':'esri','location':'./arcgis-js-api','main':'kernel'}),({'name':'@dojo','location':'./@dojo','lib':'.'}),({'name':'cldrjs','location':'./cldrjs','main':'dist/cldr'}),({'name':'globalize','location':'./globalize','main':'dist/globalize'}),({'name':'tslib','location':'./tslib','main':'tslib'}),({'name':'moment','location':'./moment','main':'moment','lib':'.'}),({'name':'dojo','location':'./dojo','lib':'.'}),({'name':'dijit','location':'./dijit','lib':'.'}),({'name':'dojox','location':'./dojox','lib':'.'}),({'name':'dstore','location':'./dojo-dstore','lib':'.'}),({'name':'maquette','location':'./maquette','main':'dist/maquette.umd','resourceTags':({'miniExclude':(function(filename, mid) {\n \t\t            return (\n \t\t              mid.indexOf(\"/polyfills/\") > -1 ||\n \t\t              (mid.indexOf(\"/dist/\") > -1 &&\n \t\t                filename.indexOf(\".umd.js\") === -1)\n \t\t            );\n \t\t          })})}),({'name':'maquette-css-transitions','location':'./maquette-css-transitions','main':'dist/maquette-css-transitions.umd','resourceTags':({'miniExclude':(function(filename, mid) {\n \t\t            return (\n \t\t              mid.indexOf(\"/dist/\") > -1 && filename.indexOf(\".umd.js\") === -1\n \t\t            );\n \t\t          })})}),({'name':'maquette-jsx','location':'./maquette-jsx','main':'dist/maquette-jsx.umd','resourceTags':({'miniExclude':(function(filename, mid) {\n \t\t            return (\n \t\t              mid.indexOf(\"/dist/\") > -1 && filename.indexOf(\".umd.js\") === -1\n \t\t            );\n \t\t          })})})],'map':({'globalize':({'cldr':'cldrjs/dist/cldr','cldr/event':'cldrjs/dist/cldr/event','cldr/supplemental':'cldrjs/dist/cldr/supplemental','cldr/unresolved':'cldrjs/dist/cldr/unresolved'})}),'async':true,'has':({'config-deferredInstrumentation':1,'dojo-config-api':0,'esri-promise-compatibility':1,'esri-webpack':1})}));\n \t\tvar defaultConfig = ({'hasCache':({'webpack':1,'host-browser':1,'dom':1,'dojo-loader':1,'dojo-has-api':1,'dojo-dom-ready-api':1,'dojo-sniff':1,'dojo-test-sniff':1,'config-deferredInstrumentation':1,'config-tlmSiblingOfDojo':1})});\n \t\tvar dojoLoader = __webpack_require__(\"./node_modules/@arcgis/webpack-plugin/loader/dojo.js\");\n \t\tdojoLoader.call(loaderScope, userConfig, defaultConfig, loaderScope, loaderScope);\n \t\tObject.keys(loaderScope.require.packs).forEach(function(key) {\n \t\t\tvar pkg = loaderScope.require.packs[key];\n \t\t\tif ((/(^\\/)|(\\:)/.test(pkg.main)\t// main path is absolute\n \t\t\t    || pkg.main.split('/').reduce(function(acc, pathComp) {\n \t\t\t\t\t\tif (acc < 0 || pathComp === '.') return acc;\n \t\t\t\t\t\treturn (pathComp === '..' ? --acc : ++acc);\n \t\t\t\t\t}, 0) <= 0) // main path is outside package\n \t\t\t\t\t&& typeof pkg.realMain === 'undefined'\t// hasn't already been adjusted\n \t\t\t) {\n \t\t\t\tpkg.realMain = pkg.main;\n \t\t\t\tpkg.main = '';\n \t\t\t}\n \t\t});\n \t\tfunction toAbsMid(name, referenceModule) {\n \t\t\tvar absMid = loaderScope.require.originalToAbsMid(name, referenceModule);\n \t\t\tif (absMid.indexOf('/') === absMid.length-1) {\n \t\t\t\tvar pkgName = absMid.substring(0, absMid.length-1);\n \t\t\t\tvar pkg = loaderScope.require.packs[pkgName];\n \t\t\t\tif (pkg && pkg.realMain) {\n \t\t\t\t\tabsMid = pkgName;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn absMid;\n \t\t}\n \t\tfunction toUrl(name, referenceModule) {\n \t\t\tvar url = loaderScope.require.originalToUrl(name, referenceModule);\n \t\t\tvar pkg = loaderScope.require.packs[name];\n \t\t\tif (pkg && pkg.realMain) {\n \t\t\t\tvar parts = url.split('?');\n \t\t\t\tif (/(^\\/)|(\\:)/.test(pkg.realMain)) {\n \t\t\t\t\t// absolute URL\n \t\t\t\t\tparts[0] = pkg.realMain;\n \t\t\t\t} else {\n \t\t\t\t\t// relative URL\n \t\t\t\t\tparts[0] = parts[0] + '/' + pkg.realMain;\n \t\t\t\t}\n \t\t\t\turl = parts.join('?');\n \t\t\t}\n \t\t\treturn url;\n \t\t}\n \t\tloaderScope.require.originalToAbsMid = loaderScope.require.toAbsMid;\n \t\tloaderScope.require.originalToUrl = loaderScope.require.toUrl;\n \t\tloaderScope.require.toAbsMid = toAbsMid;\n \t\tloaderScope.require.toUrl = toUrl;\n \t\t['baseUrl','has','rawConfig','on','signal'].forEach(function(name) {req[name] = loaderScope.require[name]})\n \t})(); /* End undefined extensions */\n\n \t// run deferred modules from other chunks\n \tcheckDeferredModules();\n","module.exports = function(userConfig, defaultConfig, global, window) { this.loaderVersion = \"1.14.2\"; (function(\n\tuserConfig,\n\tdefaultConfig\n){\n\t// summary:\n\t//\t\tThis is the \"source loader\" and is the entry point for Dojo during development. You may also load Dojo with\n\t//\t\tany AMD-compliant loader via the package main module dojo/main.\n\t// description:\n\t//\t\tThis is the \"source loader\" for Dojo. It provides an AMD-compliant loader that can be configured\n\t//\t\tto operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded\n\t//\t\tIAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package\n\t//\t\tvia the package main module dojo/main and this loader is not required; see dojo/package.json for details.\n\t//\n\t//\t\tIn order to keep compatibility with the v1.x line, this loader includes additional machinery that enables\n\t//\t\tthe dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed\n\t//\t\tvia the has.js API and statically removed via the build system.\n\t//\n\t//\t\tThis loader includes sniffing machinery to determine the environment; the following environments are supported:\n\t//\n\t//\t\t- browser\n\t//\t\t- node.js\n\t//\t\t- rhino\n\t//\n\t//\t\tThis is the so-called \"source loader\". As such, it includes many optional features that may be discarded by\n\t//\t\tbuilding a customized version with the build system.\n\n\t// Design and Implementation Notes\n\t//\n\t// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.\n\t//\n\t// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)\n\t// loader that can be configured to operate in either synchronous or asynchronous modes.\n\t//\n\t// Since this machinery implements a loader, it does not have the luxury of using a load system and/or\n\t// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:\n\t//\n\t//\t 1. Small library for use implementing the loader.\n\t//\t 2. Define the has.js API; this is used throughout the loader to bracket features.\n\t//\t 3. Define the node.js and rhino sniffs and sniff.\n\t//\t 4. Define the loader's data.\n\t//\t 5. Define the configuration machinery.\n\t//\t 6. Define the script element sniffing machinery and sniff for configuration data.\n\t//\t 7. Configure the loader IAW the provided user, default, and sniffing data.\n\t//\t 8. Define the global require function.\n\t//\t 9. Define the module resolution machinery.\n\t//\t10. Define the module and plugin module definition machinery\n\t//\t11. Define the script injection machinery.\n\t//\t12. Define the window load detection.\n\t//\t13. Define the logging API.\n\t//\t14. Define the tracing API.\n\t//\t16. Define the AMD define function.\n\t//\t17. Define the dojo v1.x provide/require machinery--so called \"legacy\" modes.\n\t//\t18. Publish global variables.\n\t//\n\t// Language and Acronyms and Idioms\n\t//\n\t// moduleId: a CJS module identifier, (used for public APIs)\n\t// mid: moduleId (used internally)\n\t// packageId: a package identifier (used for public APIs)\n\t// pid: packageId (used internally); the implied system or default package has pid===\"\"\n\t// pack: package is used internally to reference a package object (since javascript has reserved words including \"package\")\n\t// prid: plugin resource identifier\n\t// The integer constant 1 is used in place of true and 0 in place of false.\n\t//\n\t// The \"foreign-loader\" has condition is defined if another loader is being used (e.g. webpack) and this code is only\n\t// needed for resolving module identifiers based on the config.  In this case, only the functions require.toUrl and \n\t// require.toAbsMid are supported.  The require and define functions are not supported.\n\n\t// define global\n\tvar globalObject = (function(){\n\t\tif (typeof global !== 'undefined' && typeof global !== 'function') {\n\t\t\t// global spec defines a reference to the global object called 'global'\n\t\t\t// https://github.com/tc39/proposal-global\n\t\t\t// `global` is also defined in NodeJS\n\t\t\treturn global;\n\t\t}\n\t\telse if (typeof window !== 'undefined') {\n\t\t\t// window is defined in browsers\n\t\t\treturn window;\n\t\t}\n\t\telse if (typeof self !== 'undefined') {\n\t\t\t// self is defined in WebWorkers\n\t\t\treturn self;\n\t\t}\n\t\treturn this;\n\t})();\n\n\t// define a minimal library to help build the loader\n\tvar noop = function(){\n\t\t},\n\n\t\tisEmpty = function(it){\n\t\t\tfor(var p in it){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t},\n\n\t\ttoString = {}.toString,\n\n\t\tisFunction = function(it){\n\t\t\treturn toString.call(it) == \"[object Function]\";\n\t\t},\n\n\t\tisString = function(it){\n\t\t\treturn toString.call(it) == \"[object String]\";\n\t\t},\n\n\t\tisArray = function(it){\n\t\t\treturn toString.call(it) == \"[object Array]\";\n\t\t},\n\n\t\tforEach = function(vector, callback){\n\t\t\tif(vector){\n\t\t\t\tfor(var i = 0; i < vector.length;){\n\t\t\t\t\tcallback(vector[i++]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmix = function(dest, src){\n\t\t\tfor(var p in src){\n\t\t\t\tdest[p] = src[p];\n\t\t\t}\n\t\t\treturn dest;\n\t\t},\n\n\t\tmakeError = function(error, info){\n\t\t\treturn mix(new Error(error), {src:\"dojoLoader\", info:info});\n\t\t},\n\n\t\tuidSeed = 1,\n\n\t\tuid = function(){\n\t\t\t// Returns a unique identifier (within the lifetime of the document) of the form /_d+/.\n\t\t\treturn \"_\" + uidSeed++;\n\t\t},\n\n\t\t// FIXME: how to doc window.require() api\n\n\t\t// this will be the global require function; define it immediately so we can start hanging things off of it\n\t\treq = function(\n\t\t\tconfig,\t\t  //(object, optional) hash of configuration properties\n\t\t\tdependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback\n\t\t\tcallback\t  //(function, optional) lambda expression to apply to module values implied by dependencies\n\t\t){\n\t\t\treturn contextRequire(config, dependencies, callback, 0, req);\n\t\t},\n\n\t\t// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout\n\t\tglobal = globalObject,\n\n\t\tdoc = global.document,\n\n\t\telement = doc && doc.createElement(\"DiV\"),\n\n\t\thas = req.has = function(name){\n\t\t\treturn isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];\n\t\t},\n\n\t\thasCache = has.cache = defaultConfig.hasCache;\n\n\tif (isFunction(userConfig)) {\n\t\tuserConfig = userConfig(globalObject);\n\t}\n\n\thas.add = function(name, test, now, force){\n\t\t(hasCache[name]===undefined || force) && (hasCache[name] = test);\n\t\treturn now && has(name);\n\t};\n\n\t 0 && has.add(\"host-node\", userConfig.has && \"host-node\" in userConfig.has ?\n\t\tuserConfig.has[\"host-node\"] :\n\t\t(typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8));\n\tif( 0 ){\n\t\t// fixup the default config for node.js environment\n\t\trequire(\"./_base/configNode.js\").config(defaultConfig);\n\t\t// remember node's require (with respect to baseUrl==dojo's root)\n\t\tdefaultConfig.loaderPatch.nodeRequire = require;\n\t}\n\n\t 0 && has.add(\"host-rhino\", userConfig.has && \"host-rhino\" in userConfig.has ?\n\t\tuserConfig.has[\"host-rhino\"] :\n\t\t(typeof load == \"function\" && (typeof Packages == \"function\" || typeof Packages == \"object\")));\n\tif( 0 ){\n\t\t// owing to rhino's lame feature that hides the source of the script, give the user a way to specify the baseUrl...\n\t\tfor(var baseUrl = userConfig.baseUrl || \".\", arg, rhinoArgs = this.arguments, i = 0; i < rhinoArgs.length;){\n\t\t\targ = (rhinoArgs[i++] + \"\").split(\"=\");\n\t\t\tif(arg[0] == \"baseUrl\"){\n\t\t\t\tbaseUrl = arg[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tload(baseUrl + \"/_base/configRhino.js\");\n\t\trhinoDojoConfig(defaultConfig, baseUrl, rhinoArgs);\n\t}\n\n\t 0 && has.add(\"host-webworker\", ((typeof WorkerGlobalScope !== 'undefined') && (self instanceof WorkerGlobalScope)));\n\tif( 0 ){\n\t\tmix(defaultConfig.hasCache, {\n\t\t\t\"host-browser\": 0,\n\t\t\t\"dom\": 0,\n\t\t\t\"dojo-dom-ready-api\": 0,\n\t\t\t\"dojo-sniff\": 0,\n\t\t\t\"dojo-inject-api\": 1,\n\t\t\t\"host-webworker\": 1,\n\t\t\t\"dojo-guarantee-console\": 0 // console is immutable in FF30+, see https://bugs.dojotoolkit.org/ticket/18100\n\t\t});\n\n\t\tdefaultConfig.loaderPatch = {\n\t\t\tinjectUrl: function(url, callback){\n\t\t\t\t// TODO:\n\t\t\t\t//\t\tThis is not async, nor can it be in Webworkers.  It could be made better by passing\n\t\t\t\t//\t\tthe entire require array into importScripts at.  This way the scripts are loaded in\n\t\t\t\t//\t\tasync mode; even if the callbacks are ran in sync.  It is not a major issue as webworkers\n\t\t\t\t//\t\ttend to be long running where initial startup is not a major factor.\n\n\t\t\t\ttry{\n\t\t\t\t\timportScripts(url);\n\t\t\t\t\tcallback();\n\t\t\t\t}catch(e){\n\t\t\t\t\tconsole.info(\"failed to load resource (\" + url + \")\");\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// userConfig has tests override defaultConfig has tests; do this after the environment detection because\n\t// the environment detection usually sets some has feature values in the hasCache.\n\tfor(var p in userConfig.has){\n\t\thas.add(p, userConfig.has[p], 0, 1);\n\t}\n\n\t//\n\t// define the loader data\n\t//\n\n\t// the loader will use these like symbols if the loader has the traceApi; otherwise\n\t// define magic numbers so that modules can be provided as part of defaultConfig\n\tvar requested = 1,\n\t\tarrived = 2,\n\t\tnonmodule = 3,\n\t\texecuting = 4,\n\t\texecuted = 5;\n\n\tif( 0 ){\n\t\t// these make debugging nice; but using strings for symbols is a gross rookie error; don't do it for production code\n\t\trequested = \"requested\";\n\t\tarrived = \"arrived\";\n\t\tnonmodule = \"not-a-module\";\n\t\texecuting = \"executing\";\n\t\texecuted = \"executed\";\n\t}\n\n\tvar legacyMode = 0,\n\t\tsync = \"sync\",\n\t\txd = \"xd\",\n\t\tsyncExecStack = [],\n\t\tdojoRequirePlugin = 0,\n\t\tcheckDojoRequirePlugin = noop,\n\t\ttransformToAmd = noop,\n\t\tgetXhr;\n\tif( 0 ){\n\t\treq.isXdUrl = noop;\n\n\t\treq.initSyncLoader = function(dojoRequirePlugin_, checkDojoRequirePlugin_, transformToAmd_){\n\t\t\t// the first dojo/_base/loader loaded gets to define these variables; they are designed to work\n\t\t\t// in the presence of zero to many mapped dojo/_base/loaders\n\t\t\tif(!dojoRequirePlugin){\n\t\t\t\tdojoRequirePlugin = dojoRequirePlugin_;\n\t\t\t\tcheckDojoRequirePlugin = checkDojoRequirePlugin_;\n\t\t\t\ttransformToAmd = transformToAmd_;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsync:sync,\n\t\t\t\trequested:requested,\n\t\t\t\tarrived:arrived,\n\t\t\t\tnonmodule:nonmodule,\n\t\t\t\texecuting:executing,\n\t\t\t\texecuted:executed,\n\t\t\t\tsyncExecStack:syncExecStack,\n\t\t\t\tmodules:modules,\n\t\t\t\texecQ:execQ,\n\t\t\t\tgetModule:getModule,\n\t\t\t\tinjectModule:injectModule,\n\t\t\t\tsetArrived:setArrived,\n\t\t\t\tsignal:signal,\n\t\t\t\tfinishExec:finishExec,\n\t\t\t\texecModule:execModule,\n\t\t\t\tdojoRequirePlugin:dojoRequirePlugin,\n\t\t\t\tgetLegacyMode:function(){return legacyMode;},\n\t\t\t\tguardCheckComplete:guardCheckComplete\n\t\t\t};\n\t\t};\n\n\t\tif( 0  ||  0 ){\n\t\t\t// in legacy sync mode, the loader needs a minimal XHR library\n\n\t\t\tvar locationProtocol = location.protocol,\n\t\t\t\tlocationHost = location.host;\n\t\t\treq.isXdUrl = function(url){\n\t\t\t\tif(/^\\./.test(url)){\n\t\t\t\t\t// begins with a dot is always relative to page URL; therefore not xdomain\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(/^\\/\\//.test(url)){\n\t\t\t\t\t// for v1.6- backcompat, url starting with // indicates xdomain\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// get protocol and host\n\t\t\t\t// \\/+ takes care of the typical file protocol that looks like file:///drive/path/to/file\n\t\t\t\t// locationHost is falsy if file protocol => if locationProtocol matches and is \"file:\", || will return false\n\t\t\t\tvar match = url.match(/^([^\\/\\:]+\\:)\\/+([^\\/]+)/);\n\t\t\t\treturn match && (match[1] != locationProtocol || (locationHost && match[2] != locationHost));\n\t\t\t};\n\n\n\t\t\t// note: to get the file:// protocol to work in FF, you must set security.fileuri.strict_origin_policy to false in about:config\n\t\t\t 1 || has.add(\"dojo-xhr-factory\", 1);\n\t\t\t 0 && has.add(\"dojo-force-activex-xhr\",  1  && !doc.addEventListener && window.location.protocol == \"file:\");\n\t\t\thas.add(\"native-xhr\", typeof XMLHttpRequest != \"undefined\");\n\t\t\tif(has(\"native-xhr\") && ! 0 ){\n\t\t\t\tgetXhr = function(){\n\t\t\t\t\treturn new XMLHttpRequest();\n\t\t\t\t};\n\t\t\t}else{\n\t\t\t\t// if in the browser an old IE; find an xhr\n\t\t\t\tfor(var XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'], progid, i = 0; i < 3;){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tprogid = XMLHTTP_PROGIDS[i++];\n\t\t\t\t\t\tif(new ActiveXObject(progid)){\n\t\t\t\t\t\t\t// this progid works; therefore, use it from now on\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t// squelch; we're just trying to find a good ActiveX progid\n\t\t\t\t\t\t// if they all fail, then progid ends up as the last attempt and that will signal the error\n\t\t\t\t\t\t// the first time the client actually tries to exec an xhr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgetXhr = function(){\n\t\t\t\t\treturn new ActiveXObject(progid);\n\t\t\t\t};\n\t\t\t}\n\t\t\treq.getXhr = getXhr;\n\n\t\t\thas.add(\"dojo-gettext-api\", 1);\n\t\t\treq.getText = function(url, async, onLoad){\n\t\t\t\tvar xhr = getXhr();\n\t\t\t\txhr.open('GET', fixupUrl(url), false);\n\t\t\t\txhr.send(null);\n\t\t\t\tif(xhr.status == 200 || (!location.host && !xhr.status)){\n\t\t\t\t\tif(onLoad){\n\t\t\t\t\t\tonLoad(xhr.responseText, async);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tthrow makeError(\"xhrFailed\", xhr.status);\n\t\t\t\t}\n\t\t\t\treturn xhr.responseText;\n\t\t\t};\n\t\t}\n\t}else{\n\t\treq.async = 1;\n\t}\n\n\t//\n\t// loader eval\n\t//\n\tvar eval_ =   1  ?\n\t\t// noop eval if there are csp restrictions\n\t\tfunction(){} :\n\t\t// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution\n\t\tnew Function('return eval(arguments[0]);');\n\n\treq.eval =\n\t\tfunction(text, hint){\n\t\t\treturn eval_(text + \"\\r\\n//# sourceURL=\" + hint);\n\t\t};\n\n\t//\n\t// loader micro events API\n\t//\n\tvar listenerQueues = {},\n\t\terror = \"error\",\n\t\tsignal = req.signal = function(type, args){\n\t\t\tvar queue = listenerQueues[type];\n\t\t\t// notice we run a copy of the queue; this allows listeners to add/remove\n\t\t\t// other listeners without affecting this particular signal\n\t\t\tforEach(queue && queue.slice(0), function(listener){\n\t\t\t\tlistener.apply(null, isArray(args) ? args : [args]);\n\t\t\t});\n\t\t},\n\t\ton = req.on = function(type, listener){\n\t\t\t// notice a queue is not created until a client actually connects\n\t\t\tvar queue = listenerQueues[type] || (listenerQueues[type] = []);\n\t\t\tqueue.push(listener);\n\t\t\treturn {\n\t\t\t\tremove:function(){\n\t\t\t\t\tfor(var i = 0; i<queue.length; i++){\n\t\t\t\t\t\tif(queue[i]===listener){\n\t\t\t\t\t\t\tqueue.splice(i, 1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded\n\t// lexical variables hold key loader data structures to help with minification; these may be completely,\n\t// one-time initialized by defaultConfig for optimized/built versions\n\tvar\n\t\taliases\n\t\t\t// a vector of pairs of [regexs or string, replacement] => (alias, actual)\n\t\t\t= [],\n\n\t\tpaths\n\t\t\t// CommonJS paths\n\t\t\t= {},\n\n\t\tpathsMapProg\n\t\t\t// list of (from-path, to-path, regex, length) derived from paths;\n\t\t\t// a \"program\" to apply paths; see computeMapProg\n\t\t\t= [],\n\n\t\tpacks\n\t\t\t// a map from packageId to package configuration object; see fixupPackageInfo\n\t\t\t= {},\n\n\t\tmap = req.map\n\t\t\t// AMD map config variable; dojo/_base/kernel needs req.map to figure out the scope map\n\t\t\t= {},\n\n\t\tmapProgs\n\t\t\t// vector of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value\n\t\t\t= [],\n\n\t\tmodules\n\t\t\t// A hash:(mid) --> (module-object) the module namespace\n\t\t\t//\n\t\t\t// pid: the package identifier to which the module belongs (e.g., \"dojo\"); \"\" indicates the system or default package\n\t\t\t// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., \"dojo/io/script\")\n\t\t\t// url: the URL from which the module was retrieved\n\t\t\t// pack: the package object of the package to which the module belongs\n\t\t\t// executed: 0 => not executed; executing => in the process of traversing deps and running factory; executed => factory has been executed\n\t\t\t// deps: the dependency vector for this module (vector of modules objects)\n\t\t\t// def: the factory for this module\n\t\t\t// result: the result of the running the factory for this module\n\t\t\t// injected: (0 | requested | arrived) the status of the module; nonmodule means the resource did not call define\n\t\t\t// load: plugin load function; applicable only for plugins\n\t\t\t//\n\t\t\t// Modules go through several phases in creation:\n\t\t\t//\n\t\t\t// 1. Requested: some other module's definition or a require application contained the requested module in\n\t\t\t//\t  its dependency vector or executing code explicitly demands a module via req.require.\n\t\t\t//\n\t\t\t// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL\n\t\t\t//\n\t\t\t// 3. Loaded: the resource injected in [2] has been evaluated.\n\t\t\t//\n\t\t\t// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some\n\t\t\t//\t  resources may just contain a bundle of code and never formally define a module via define\n\t\t\t//\n\t\t\t// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.\n\t\t\t= {},\n\n\t\tcacheBust\n\t\t\t// query string to append to module URLs to bust browser cache\n\t\t\t= \"\",\n\n\t\tcache\n\t\t\t// hash:(mid | url)-->(function | string)\n\t\t\t//\n\t\t\t// A cache of resources. The resources arrive via a config.cache object, which is a hash from either mid --> function or\n\t\t\t// url --> string. The url key is distinguished from the mid key by always containing the prefix \"url:\". url keys as provided\n\t\t\t// by config.cache always have a string value that represents the contents of the resource at the given url. mid keys as provided\n\t\t\t// by configl.cache always have a function value that causes the same code to execute as if the module was script injected.\n\t\t\t//\n\t\t\t// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate keys as given\n\t\t\t// by any mappings *iff* the config.cache was received as part of a module resource request.\n\t\t\t//\n\t\t\t// Further, for mid keys, the implied url is computed and the value is entered into that key as well. This allows mapped modules\n\t\t\t// to retrieve cached items that may have arrived consequent to another namespace.\n\t\t\t//\n\t\t\t = {},\n\n\t\turlKeyPrefix\n\t\t\t// the prefix to prepend to a URL key in the cache.\n\t\t\t= \"url:\",\n\n\t\tpendingCacheInsert\n\t\t\t// hash:(mid)-->(function)\n\t\t\t//\n\t\t\t// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are\n\t\t\t// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another\n\t\t\t// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending\n\t\t\t// cache for the local configuration, possibly relocating modules.\n\t\t\t = {},\n\n\t\tdojoSniffConfig\n\t\t\t// map of configuration variables\n\t\t\t// give the data-dojo-config as sniffed from the document (if any)\n\t\t\t= {},\n\n\t\tinsertPointSibling\n\t\t\t// the nodes used to locate where scripts are injected into the document\n\t\t\t= 0;\n\n\tif( 1 ){\n\t\tif (! 1 ) {\n\t\t\tvar consumePendingCacheInsert = function(referenceModule, clear){\n\t\t\t\t\tclear = clear !== false;\n\t\t\t\t\tvar p, item, match, now, m;\n\t\t\t\t\tfor(p in pendingCacheInsert){\n\t\t\t\t\t\titem = pendingCacheInsert[p];\n\t\t\t\t\t\tmatch = p.match(/^url\\:(.+)/);\n\t\t\t\t\t\tif(match){\n\t\t\t\t\t\t\tcache[urlKeyPrefix + toUrl(match[1], referenceModule)] =  item;\n\t\t\t\t\t\t}else if(p==\"*now\"){\n\t\t\t\t\t\t\tnow = item;\n\t\t\t\t\t\t}else if(p!=\"*noref\"){\n\t\t\t\t\t\t\tm = getModuleInfo(p, referenceModule, true);\n\t\t\t\t\t\t\tcache[m.mid] = cache[urlKeyPrefix + m.url] = item;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(now){\n\t\t\t\t\t\tnow(createRequire(referenceModule));\n\t\t\t\t\t}\n\t\t\t\t\tif(clear){\n\t\t\t\t\t\tpendingCacheInsert = {};\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\tvar escapeString = function(s){\n\t\t\t\treturn s.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, function(c){ return \"\\\\\" + c; });\n\t\t\t},\n\n\t\t\tcomputeMapProg = function(map, dest){\n\t\t\t\t// This routine takes a map as represented by a JavaScript object and initializes dest, a vector of\n\t\t\t\t// quads of (map-key, map-value, refex-for-map-key, length-of-map-key), sorted decreasing by length-\n\t\t\t\t// of-map-key. The regex looks for the map-key followed by either \"/\" or end-of-string at the beginning\n\t\t\t\t// of a the search source. Notice the map-value is irrelevant to the algorithm\n\t\t\t\tdest.splice(0, dest.length);\n\t\t\t\tfor(var p in map){\n\t\t\t\t\tdest.push([\n\t\t\t\t\t\tp,\n\t\t\t\t\t\tmap[p],\n\t\t\t\t\t\tnew RegExp(\"^\" + escapeString(p) + \"(\\/|$)\"),\n\t\t\t\t\t\tp.length]);\n\t\t\t\t}\n\t\t\t\tdest.sort(function(lhs, rhs){ return rhs[3] - lhs[3]; });\n\t\t\t\treturn dest;\n\t\t\t},\n\n\t\t\tcomputeAliases = function(config, dest){\n\t\t\t\tforEach(config, function(pair){\n\t\t\t\t\t// take a fixed-up copy...\n\t\t\t\t\tdest.push([isString(pair[0]) ? new RegExp(\"^\" + escapeString(pair[0]) + \"$\") : pair[0], pair[1]]);\n\t\t\t\t});\n\t\t\t},\n\n\n\t\t\tfixupPackageInfo = function(packageInfo){\n\t\t\t\t// calculate the precise (name, location, main, mappings) for a package\n\t\t\t\tvar name = packageInfo.name;\n\t\t\t\tif(!name){\n\t\t\t\t\t// packageInfo must be a string that gives the name\n\t\t\t\t\tname = packageInfo;\n\t\t\t\t\tpackageInfo = {name:name};\n\t\t\t\t}\n\t\t\t\tpackageInfo = mix({main:\"main\"}, packageInfo);\n\t\t\t\tpackageInfo.location = packageInfo.location ? packageInfo.location : name;\n\n\t\t\t\t// packageMap is deprecated in favor of AMD map\n\t\t\t\tif(packageInfo.packageMap){\n\t\t\t\t\tmap[name] = packageInfo.packageMap;\n\t\t\t\t}\n\n\t\t\t\tif(!packageInfo.main.indexOf(\"./\")){\n\t\t\t\t\tpackageInfo.main = packageInfo.main.substring(2);\n\t\t\t\t}\n\n\t\t\t\t// now that we've got a fully-resolved package object, push it into the configuration\n\t\t\t\tpacks[name] = packageInfo;\n\t\t\t},\n\n\t\t\tdelayedModuleConfig\n\t\t\t\t// module config cannot be consumed until the loader is completely initialized; therefore, all\n\t\t\t\t// module config detected during booting is memorized and applied at the end of loader initialization\n\t\t\t\t// TODO: this is a bit of a kludge; all config should be moved to end of loader initialization, but\n\t\t\t\t// we'll delay this chore and do it with a final loader 1.x cleanup after the 2.x loader prototyping is complete\n\t\t\t\t= [],\n\n\n\t\t\tconfig = function(config, booting, referenceModule){\n\t\t\t\tfor(var p in config){\n\t\t\t\t\tif(p==\"waitSeconds\"){\n\t\t\t\t\t\treq.waitms = (config[p] || 0) * 1000;\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"cacheBust\"){\n\t\t\t\t\t\tcacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + \"\") : \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"baseUrl\" || p==\"combo\"){\n\t\t\t\t\t\treq[p] = config[p];\n\t\t\t\t\t}\n\t\t\t\t\tif( 0  && p==\"async\"){\n\t\t\t\t\t\t// falsy or \"sync\" => legacy sync loader\n\t\t\t\t\t\t// \"xd\" => sync but loading xdomain tree and therefore loading asynchronously (not configurable, set automatically by the loader)\n\t\t\t\t\t\t// \"legacyAsync\" => permanently in \"xd\" by choice\n\t\t\t\t\t\t// \"debugAtAllCosts\" => trying to load everything via script injection (not implemented)\n\t\t\t\t\t\t// otherwise, must be truthy => AMD\n\t\t\t\t\t\t// legacyMode: sync | legacyAsync | xd | false\n\t\t\t\t\t\tvar mode = config[p];\n\t\t\t\t\t\treq.legacyMode = legacyMode = (isString(mode) && /sync|legacyAsync/.test(mode) ? mode : (!mode ? sync : false));\n\t\t\t\t\t\treq.async = !legacyMode;\n\t\t\t\t\t}\n\t\t\t\t\tif(config[p]!==hasCache){\n\t\t\t\t\t\t// accumulate raw config info for client apps which can use this to pass their own config\n\t\t\t\t\t\treq.rawConfig[p] = config[p];\n\t\t\t\t\t\tp!=\"has\" && has.add(\"config-\"+p, config[p], 0, booting);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// make sure baseUrl exists\n\t\t\t\tif(!req.baseUrl){\n\t\t\t\t\treq.baseUrl = \"./\";\n\t\t\t\t}\n\t\t\t\t// make sure baseUrl ends with a slash\n\t\t\t\tif(!/\\/$/.test(req.baseUrl)){\n\t\t\t\t\treq.baseUrl += \"/\";\n\t\t\t\t}\n\n\t\t\t\t// now do the special work for has, packages, packagePaths, paths, aliases, and cache\n\n\t\t\t\tfor(p in config.has){\n\t\t\t\t\thas.add(p, config.has[p], 0, booting);\n\t\t\t\t}\n\n\t\t\t\t// for each package found in any packages config item, augment the packs map owned by the loader\n\t\t\t\tforEach(config.packages, fixupPackageInfo);\n\n\t\t\t\t// for each packagePath found in any packagePaths config item, augment the packageConfig\n\t\t\t\t// packagePaths is deprecated; remove in 2.0\n\t\t\t\tfor(var baseUrl in config.packagePaths){\n\t\t\t\t\tforEach(config.packagePaths[baseUrl], function(packageInfo){\n\t\t\t\t\t\tvar location = baseUrl + \"/\" + packageInfo;\n\t\t\t\t\t\tif(isString(packageInfo)){\n\t\t\t\t\t\t\tpackageInfo = {name:packageInfo};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpackageInfo.location = location;\n\t\t\t\t\t\tfixupPackageInfo(packageInfo);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// notice that computeMapProg treats the dest as a reference; therefore, if/when that variable\n\t\t\t\t// is published (see dojo-publish-privates), the published variable will always hold a valid value.\n\n\t\t\t\t// this must come after all package processing since package processing may mutate map\n\t\t\t\tcomputeMapProg(mix(map, config.map), mapProgs);\n\t\t\t\tforEach(mapProgs, function(item){\n\t\t\t\t\titem[1] = computeMapProg(item[1], []);\n\t\t\t\t\tif(item[0]==\"*\"){\n\t\t\t\t\t\tmapProgs.star = item;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// push in any paths and recompute the internal pathmap\n\t\t\t\tcomputeMapProg(mix(paths, config.paths), pathsMapProg);\n\n\t\t\t\t// aliases\n\t\t\t\tcomputeAliases(config.aliases, aliases);\n\n\t\t\t\tif (! 1 ) {\n\t\t\t\t\tif(booting){\n\t\t\t\t\t\tdelayedModuleConfig.push({config:config.config});\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(p in config.config){\n\t\t\t\t\t\t\tvar module = getModule(p, referenceModule);\n\t\t\t\t\t\t\tmodule.config = mix(module.config || {}, config.config[p]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// push in any new cache values\n\t\t\t\t\tif(config.cache){\n\t\t\t\t\t\tconsumePendingCacheInsert();\n\t\t\t\t\t\tpendingCacheInsert = config.cache;\n\t\t\t\t\t\t//inject now all depencies so cache is available for mapped module\n\t\t\t\t\t\tconsumePendingCacheInsert(0, !!config.cache[\"*noref\"]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsignal(\"config\", [config, req.rawConfig]);\n\t\t\t};\n\n\t\t//\n\t\t// execute the various sniffs; userConfig can override and value\n\t\t//\n\n\t\tif( 0  ||  0 ){\n\t\t\t// the sniff regex looks for a src attribute ending in dojo.js, optionally preceded with a path.\n\t\t\t// match[3] returns the path to dojo.js (if any) without the trailing slash. This is used for the\n\t\t\t// dojo location on CDN deployments and baseUrl when either/both of these are not provided\n\t\t\t// explicitly in the config data; this is the 1.6- behavior.\n\n\t\t\tvar scripts = doc.getElementsByTagName(\"script\"),\n\t\t\t\ti = 0,\n\t\t\t\tscript, dojoDir, src, match;\n\t\t\twhile(i < scripts.length){\n\t\t\t\tscript = scripts[i++];\n\t\t\t\tif((src = script.getAttribute(\"src\")) && (match = src.match(/(((.*)\\/)|^)dojo\\.js(\\W|$)/i))){\n\t\t\t\t\t// sniff dojoDir and baseUrl\n\t\t\t\t\tdojoDir = match[3] || \"\";\n\t\t\t\t\tdefaultConfig.baseUrl = defaultConfig.baseUrl || dojoDir;\n\n\t\t\t\t\t// remember an insertPointSibling\n\t\t\t\t\tinsertPointSibling = script;\n\t\t\t\t}\n\n\t\t\t\t// sniff configuration on attribute in script element\n\t\t\t\tif((src = (script.getAttribute(\"data-dojo-config\") || script.getAttribute(\"djConfig\")))){\n\t\t\t\t\tdojoSniffConfig = req.eval(\"({ \" + src + \" })\", \"data-dojo-config\");\n\n\t\t\t\t\t// remember an insertPointSibling\n\t\t\t\t\tinsertPointSibling = script;\n\t\t\t\t}\n\n\t\t\t\t// sniff requirejs attribute\n\t\t\t\tif( 0 ){\n\t\t\t\t\tif((src = script.getAttribute(\"data-main\"))){\n\t\t\t\t\t\tdojoSniffConfig.deps = dojoSniffConfig.deps || [src];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif( 0 ){\n\t\t\t// pass down doh.testConfig from parent as if it were a data-dojo-config\n\t\t\ttry{\n\t\t\t\tif(window.parent != window && window.parent.require){\n\t\t\t\t\tvar doh = window.parent.require(\"doh\");\n\t\t\t\t\tdoh && mix(dojoSniffConfig, doh.testConfig);\n\t\t\t\t}\n\t\t\t}catch(e){}\n\t\t}\n\n\t\t// configure the loader; let the user override defaults\n\t\treq.rawConfig = {};\n\t\tconfig(defaultConfig, 1);\n\n\t\t// do this before setting userConfig/sniffConfig to allow userConfig/sniff overrides\n\t\tif( 0 ){\n\t\t\tpacks.dojo.location = dojoDir;\n\t\t\tif(dojoDir){\n\t\t\t\tdojoDir += \"/\";\n\t\t\t}\n\t\t\tpacks.dijit.location = dojoDir + \"../dijit/\";\n\t\t\tpacks.dojox.location = dojoDir + \"../dojox/\";\n\t\t}\n\n\t\tconfig(userConfig, 1);\n\t\tconfig(dojoSniffConfig, 1);\n\n\t}else{\n\t\t// no config API, assume defaultConfig has everything the loader needs...for the entire lifetime of the application\n\t\tpaths = defaultConfig.paths;\n\t\tpathsMapProg = defaultConfig.pathsMapProg;\n\t\tpacks = defaultConfig.packs;\n\t\taliases = defaultConfig.aliases;\n\t\tmapProgs = defaultConfig.mapProgs;\n\t\tmodules = defaultConfig.modules;\n\t\tcache = defaultConfig.cache;\n\t\tcacheBust = defaultConfig.cacheBust;\n\n\t\t// remember the default config for other processes (e.g., dojo/config)\n\t\treq.rawConfig = defaultConfig;\n\t}\n\n\n\tif (! 1 ) {\n\t\tif( 0 ){\n\t\t\treq.combo = req.combo || {add:noop};\n\t\t\tvar comboPending = 0,\n\t\t\t\tcombosPending = [],\n\t\t\t\tcomboPendingTimer = null;\n\t\t}\n\t\t\n\n\t\t// build the loader machinery iaw configuration, including has feature tests\n\t\tvar injectDependencies = function(module){\n\t\t\t\t// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies\n\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\tforEach(module.deps, injectModule);\n\t\t\t\t\tif( 0  && comboPending && !comboPendingTimer){\n\t\t\t\t\t\tcomboPendingTimer = setTimeout(function() {\n\t\t\t\t\t\t\tcomboPending = 0;\n\t\t\t\t\t\t\tcomboPendingTimer = null;\n\t\t\t\t\t\t\treq.combo.done(function(mids, url) {\n\t\t\t\t\t\t\t\tvar onLoadCallback= function(){\n\t\t\t\t\t\t\t\t\t// defQ is a vector of module definitions 1-to-1, onto mids\n\t\t\t\t\t\t\t\t\trunDefQ(0, mids);\n\t\t\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tcombosPending.push(mids);\n\t\t\t\t\t\t\t\tinjectingModule = mids;\n\t\t\t\t\t\t\t\treq.injectUrl(url, onLoadCallback, mids);\n\t\t\t\t\t\t\t\tinjectingModule = 0;\n\t\t\t\t\t\t\t}, req);\n\t\t\t\t\t\t}, 0);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tcontextRequire = function(a1, a2, a3, referenceModule, contextRequire){\n\t\t\t\tvar module, syntheticMid;\n\t\t\t\tif(isString(a1)){\n\t\t\t\t\t// signature is (moduleId)\n\t\t\t\t\tmodule = getModule(a1, referenceModule, true);\n\t\t\t\t\tif(module && module.executed){\n\t\t\t\t\t\treturn module.result;\n\t\t\t\t\t}\n\t\t\t\t\tthrow makeError(\"undefinedModule\", a1);\n\t\t\t\t}\n\t\t\t\tif(!isArray(a1)){\n\t\t\t\t\t// a1 is a configuration\n\t\t\t\t\tconfig(a1, 0, referenceModule);\n\n\t\t\t\t\t// juggle args; (a2, a3) may be (dependencies, callback)\n\t\t\t\t\ta1 = a2;\n\t\t\t\t\ta2 = a3;\n\t\t\t\t}\n\t\t\t\tif(isArray(a1)){\n\t\t\t\t\t// signature is (requestList [,callback])\n\t\t\t\t\tif(!a1.length){\n\t\t\t\t\t\ta2 && a2();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsyntheticMid = \"require*\" + uid();\n\n\t\t\t\t\t\t// resolve the request list with respect to the reference module\n\t\t\t\t\t\tfor(var mid, deps = [], i = 0; i < a1.length;){\n\t\t\t\t\t\t\tmid = a1[i++];\n\t\t\t\t\t\t\tdeps.push(getModule(mid, referenceModule));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// construct a synthetic module to control execution of the requestList, and, optionally, callback\n\t\t\t\t\t\tmodule = mix(makeModuleInfo(\"\", syntheticMid, 0, \"\"), {\n\t\t\t\t\t\t\tinjected: arrived,\n\t\t\t\t\t\t\tdeps: deps,\n\t\t\t\t\t\t\tdef: a2 || noop,\n\t\t\t\t\t\t\trequire: referenceModule ? referenceModule.require : req,\n\t\t\t\t\t\t\tgc: 1 //garbage collect\n\t\t\t\t\t\t});\n\t\t\t\t\t\tmodules[module.mid] = module;\n\n\t\t\t\t\t\t// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies\n\t\t\t\t\t\tinjectDependencies(module);\n\n\t\t\t\t\t\t// try to immediately execute\n\t\t\t\t\t\t// if already traversing a factory tree, then strict causes circular dependency to abort the execution; maybe\n\t\t\t\t\t\t// it's possible to execute this require later after the current traversal completes and avoid the circular dependency.\n\t\t\t\t\t\t// ...but *always* insist on immediate in synch mode\n\t\t\t\t\t\tvar strict = checkCompleteGuard && legacyMode!=sync;\n\t\t\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\t\t\texecModule(module, strict);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif(!module.executed){\n\t\t\t\t\t\t\t// some deps weren't on board or circular dependency detected and strict; therefore, push into the execQ\n\t\t\t\t\t\t\texecQ.push(module);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn contextRequire;\n\t\t\t},\n\n\t\t\tcreateRequire = function(module){\n\t\t\t\tif(!module){\n\t\t\t\t\treturn req;\n\t\t\t\t}\n\t\t\t\tvar result = module.require;\n\t\t\t\tif(!result){\n\t\t\t\t\tresult = function(a1, a2, a3){\n\t\t\t\t\t\treturn contextRequire(a1, a2, a3, module, result);\n\t\t\t\t\t};\n\t\t\t\t\tmodule.require = mix(result, req);\n\t\t\t\t\tresult.module = module;\n\t\t\t\t\tresult.toUrl = function(name){\n\t\t\t\t\t\treturn toUrl(name, module);\n\t\t\t\t\t};\n\t\t\t\t\tresult.toAbsMid = function(mid){\n\t\t\t\t\t\treturn toAbsMid(mid, module);\n\t\t\t\t\t};\n\t\t\t\t\tif( 0 ){\n\t\t\t\t\t\tresult.undef = function(mid){\n\t\t\t\t\t\t\treq.undef(mid, module);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif( 0 ){\n\t\t\t\t\t\tresult.syncLoadNls = function(mid){\n\t\t\t\t\t\t\tvar nlsModuleInfo = getModuleInfo(mid, module),\n\t\t\t\t\t\t\t\tnlsModule = modules[nlsModuleInfo.mid];\n\t\t\t\t\t\t\tif(!nlsModule || !nlsModule.executed){\n\t\t\t\t\t\t\t\tcached = cache[nlsModuleInfo.mid] || cache[urlKeyPrefix + nlsModuleInfo.url];\n\t\t\t\t\t\t\t\tif(cached){\n\t\t\t\t\t\t\t\t\tevalModuleText(cached);\n\t\t\t\t\t\t\t\t\tnlsModule = modules[nlsModuleInfo.mid];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn nlsModule && nlsModule.executed && nlsModule.result;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\n\t\t  execQ =\n\t\t\t\t// The list of modules that need to be evaluated.\n\t\t\t\t[],\n\n\t\t\tdefQ =\n\t\t\t\t// The queue of define arguments sent to loader.\n\t\t\t\t[],\n\n\t\t\twaiting =\n\t\t\t\t// The set of modules upon which the loader is waiting for definition to arrive\n\t\t\t\t{},\n\n\t\t\tsetRequested = function(module){\n\t\t\t\tmodule.injected = requested;\n\t\t\t\twaiting[module.mid] = 1;\n\t\t\t\tif(module.url){\n\t\t\t\t\twaiting[module.url] = module.pack || 1;\n\t\t\t\t}\n\t\t\t\tstartTimer();\n\t\t\t},\n\n\t\t\tsetArrived = function(module){\n\t\t\t\tmodule.injected = arrived;\n\t\t\t\tdelete waiting[module.mid];\n\t\t\t\tif(module.url){\n\t\t\t\t\tdelete waiting[module.url];\n\t\t\t\t}\n\t\t\t\tif(isEmpty(waiting)){\n\t\t\t\t\tclearTimer();\n\t\t\t\t\t 0  && legacyMode==xd && (legacyMode = sync);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\texecComplete = req.idle =\n\t\t\t\t// says the loader has completed (or not) its work\n\t\t\t\tfunction(){\n\t\t\t\t\treturn !defQ.length && isEmpty(waiting) && !execQ.length && !checkCompleteGuard;\n\t\t\t\t};\n\t}\n\n\tvar runMapProg = function(targetMid, map){\n\t\t\t// search for targetMid in map; return the map item if found; falsy otherwise\n\t\t\tif(map){\n\t\t\tfor(var i = 0; i < map.length; i++){\n\t\t\t\tif(map[i][2].test(targetMid)){\n\t\t\t\t\treturn map[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\tcompactPath = function(path){\n\t\t\tvar result = [],\n\t\t\t\tsegment, lastSegment;\n\t\t\tpath = path.replace(/\\\\/g, '/').split('/');\n\t\t\twhile(path.length){\n\t\t\t\tsegment = path.shift();\n\t\t\t\tif(segment==\"..\" && result.length && lastSegment!=\"..\"){\n\t\t\t\t\tresult.pop();\n\t\t\t\t\tlastSegment = result[result.length - 1];\n\t\t\t\t}else if(segment!=\".\"){\n\t\t\t\t\tresult.push(lastSegment= segment);\n\t\t\t\t} // else ignore \".\"\n\t\t\t}\n\t\t\treturn result.join(\"/\");\n\t\t},\n\n\t\tmakeModuleInfo = function(pid, mid, pack, url){\n\t\t\tif( 0 ){\n\t\t\t\tvar xd= req.isXdUrl(url);\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0, isXd:xd, isAmd:!!(xd || (packs[pid] && packs[pid].isAmd))};\n\t\t\t}else{\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};\n\t\t\t}\n\t\t},\n\n\t\tgetModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate, fromPendingCache){\n\t\t\t// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)\n\t\t\t// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader\n\t\t\tvar pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;\n\t\t\trequestedMid = mid;\n\t\t\tisRelative = /^\\./.test(mid);\n\t\t\tif(/(^\\/)|(\\:)|(\\.js$)/.test(mid) || (isRelative && !referenceModule)){\n\t\t\t\t// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page\n\t\t\t\t// whatever it is, it's not a module but just a URL of some sort\n\t\t\t\t// note: pid===0 indicates the routine is returning an unmodified mid\n\n\t\t\t\treturn makeModuleInfo(0, mid, 0, mid);\n\t\t\t}else{\n\t\t\t\t// relative module ids are relative to the referenceModule; get rid of any dots\n\t\t\t\tmid = compactPath(isRelative ? (referenceModule.mid + \"/../\" + mid) : mid);\n\t\t\t\tif(/^\\./.test(mid)){\n\t\t\t\t\tthrow makeError(\"irrationalPath\", mid);\n\t\t\t\t}\n\t\t\t\t// at this point, mid is an absolute mid\n\n\t\t\t\t// map the mid\n\t\t\t\tif(!fromPendingCache && !isRelative && mapProgs.star){\n\t\t\t\t\tmapItem = runMapProg(mid, mapProgs.star[1]);\n\t\t\t\t}\n\t\t\t\tif(!mapItem && referenceModule){\n\t\t\t\t\tmapItem = runMapProg(referenceModule.mid, mapProgs);\n\t\t\t\t\tmapItem = mapItem && runMapProg(mid, mapItem[1]);\n\t\t\t\t}\n\n\t\t\t\tif(mapItem){\n\t\t\t\t\tmid = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t\t\t}\n\n\t\t\t\tmatch = mid.match(/^([^\\/]+)(\\/(.+))?$/);\n\t\t\t\tpid = match ? match[1] : \"\";\n\t\t\t\tif((pack = packs[pid])){\n\t\t\t\t\tmid = pid + \"/\" + (midInPackage = (match[3] || pack.main));\n\t\t\t\t}else{\n\t\t\t\t\tpid = \"\";\n\t\t\t\t}\n\n\t\t\t\t// search aliases\n\t\t\t\tvar candidateLength = 0,\n\t\t\t\t\tcandidate = 0;\n\t\t\t\tforEach(aliases, function(pair){\n\t\t\t\t\tvar match = mid.match(pair[0]);\n\t\t\t\t\tif(match && match.length>candidateLength){\n\t\t\t\t\t\tcandidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(candidate){\n\t\t\t\t\treturn getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate);\n\t\t\t\t}\n\n\t\t\t\tresult = modules[mid];\n\t\t\t\tif(result){\n\t\t\t\t\treturn alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the\n\t\t\t// fully resolved (i.e., all relative indicators and package mapping resolved) module id\n\n\t\t\t// note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid\n\t\t\tmapItem = runMapProg(mid, pathsMapProg);\n\t\t\tif(mapItem){\n\t\t\t\turl = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t}else if(pid){\n\t\t\t\turl = (pack.location.slice(-1) === '/' ? pack.location.slice(0, -1) : pack.location) + \"/\" + midInPackage;\n\t\t\t}else if( 0 ){\n\t\t\t\turl = \"../\" + mid;\n\t\t\t}else{\n\t\t\t\turl = mid;\n\t\t\t}\n\t\t\t// if result is not absolute, add baseUrl\n\t\t\tif(!(/(^\\/)|(\\:)/.test(url))){\n\t\t\t\turl = baseUrl + url;\n\t\t\t}\n\t\t\turl += \".js\";\n\t\t\treturn makeModuleInfo(pid, mid, pack, compactPath(url));\n\t\t},\n\n\t\tgetModuleInfo = function(mid, referenceModule, fromPendingCache){\n\t\t\treturn getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, mapProgs, pathsMapProg, aliases, undefined, fromPendingCache);\n\t\t};\n\n\tif (! 1 ) {\n\t\tvar resolvePluginResourceId = function(plugin, prid, referenceModule){\n\t\t\t\treturn plugin.normalize ? plugin.normalize(prid, function(mid){return toAbsMid(mid, referenceModule);}) : toAbsMid(prid, referenceModule);\n\t\t\t},\n\n\t\t\tdynamicPluginUidGenerator = 0,\n\n\t\t\tgetModule = function(mid, referenceModule, immediate){\n\t\t\t\t// compute and optionally construct (if necessary) the module implied by the mid with respect to referenceModule\n\t\t\t\tvar match, plugin, prid, result;\n\t\t\t\tmatch = mid.match(/^(.+?)\\!(.*)$/);\n\t\t\t\tif(match){\n\t\t\t\t\t// name was <plugin-module>!<plugin-resource-id>\n\t\t\t\t\tplugin = getModule(match[1], referenceModule, immediate);\n\n\t\t\t\t\tif( 0  && legacyMode == sync && !plugin.executed){\n\t\t\t\t\t\tinjectModule(plugin);\n\t\t\t\t\t\tif(plugin.injected===arrived && !plugin.executed){\n\t\t\t\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\t\t\t\texecModule(plugin);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(plugin.executed){\n\t\t\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// we are in xdomain mode for some reason\n\t\t\t\t\t\t\texecQ.unshift(plugin);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\tif(plugin.executed === executed && !plugin.load){\n\t\t\t\t\t\t// executed the module not knowing it was a plugin\n\t\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t\t}\n\n\t\t\t\t\t// if the plugin has not been loaded, then can't resolve the prid and  must assume this plugin is dynamic until we find out otherwise\n\t\t\t\t\tif(plugin.load){\n\t\t\t\t\t\tprid = resolvePluginResourceId(plugin, match[2], referenceModule);\n\t\t\t\t\t\tmid = (plugin.mid + \"!\" + (plugin.dynamic ? ++dynamicPluginUidGenerator + \"!\" : \"\") + prid);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tprid = match[2];\n\t\t\t\t\t\tmid = plugin.mid + \"!\" + (++dynamicPluginUidGenerator) + \"!waitingForPlugin\";\n\t\t\t\t\t}\n\t\t\t\t\tresult = {plugin:plugin, mid:mid, req:createRequire(referenceModule), prid:prid};\n\t\t\t\t}else{\n\t\t\t\t\tresult = getModuleInfo(mid, referenceModule);\n\t\t\t\t}\n\t\t\t\treturn modules[result.mid] || (!immediate && (modules[result.mid] = result));\n\t\t\t};\n\t}\n\n\tvar toAbsMid = req.toAbsMid = function(mid, referenceModule){\n\t\t\treturn getModuleInfo(mid, referenceModule).mid;\n\t\t},\n\n\t\ttoUrl = req.toUrl = function(name, referenceModule){\n\t\t\tvar moduleInfo = getModuleInfo(name+\"/x\", referenceModule),\n\t\t\t\turl= moduleInfo.url;\n\t\t\treturn fixupUrl(moduleInfo.pid===0 ?\n\t\t\t\t// if pid===0, then name had a protocol or absolute path; either way, toUrl is the identify function in such cases\n\t\t\t\tname :\n\t\t\t\t// \"/x.js\" since getModuleInfo automatically appends \".js\" and we appended \"/x\" to make name look like a module id\n\t\t\t\turl.substring(0, url.length-5)\n\t\t\t);\n\t\t};\n\n\tif (! 1 ) {\n\t\tvar nonModuleProps = {\n\t\t\t\tinjected: arrived,\n\t\t\t\texecuted: executed,\n\t\t\t\tdef: nonmodule,\n\t\t\t\tresult: nonmodule\n\t\t\t},\n\n\t\t\tmakeCjs = function(mid){\n\t\t\t\treturn modules[mid] = mix({mid:mid}, nonModuleProps);\n\t\t\t},\n\n\t\t\tcjsRequireModule = makeCjs(\"require\"),\n\t\t\tcjsExportsModule = makeCjs(\"exports\"),\n\t\t\tcjsModuleModule = makeCjs(\"module\"),\n\n\t\t\trunFactory = function(module, args){\n\t\t\t\treq.trace(\"loader-run-factory\", [module.mid]);\n\t\t\t\tvar factory = module.def,\n\t\t\t\t\tresult;\n\t\t\t\t 0  && syncExecStack.unshift(module);\n\t\t\t\tif( 0 ){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tresult= isFunction(factory) ? factory.apply(null, args) : factory;\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tsignal(error, module.result = makeError(\"factoryThrew\", [module, e]));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tresult= isFunction(factory) ? factory.apply(null, args) : factory;\n\t\t\t\t}\n\t\t\t\tmodule.result = result===undefined && module.cjs ? module.cjs.exports : result;\n\t\t\t\t 0  && syncExecStack.shift(module);\n\t\t\t},\n\n\t\t\tabortExec = {},\n\n\t\t\tdefOrder = 0,\n\n\t\t\tpromoteModuleToPlugin = function(pluginModule){\n\t\t\t\tvar plugin = pluginModule.result;\n\t\t\t\tpluginModule.dynamic = plugin.dynamic;\n\t\t\t\tpluginModule.normalize = plugin.normalize;\n\t\t\t\tpluginModule.load = plugin.load;\n\t\t\t\treturn pluginModule;\n\t\t\t},\n\n\t\t\tresolvePluginLoadQ = function(plugin){\n\t\t\t\t// plugins is a newly executed module that has a loadQ waiting to run\n\n\t\t\t\t// step 1: traverse the loadQ and fixup the mid and prid; remember the map from original mid to new mid\n\t\t\t\t// recall the original mid was created before the plugin was on board and therefore it was impossible to\n\t\t\t\t// compute the final mid; accordingly, prid may or may not change, but the mid will definitely change\n\t\t\t\tvar map = {};\n\t\t\t\tforEach(plugin.loadQ, function(pseudoPluginResource){\n\t\t\t\t\t// manufacture and insert the real module in modules\n\t\t\t\t\tvar prid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module),\n\t\t\t\t\t\tmid = plugin.dynamic ? pseudoPluginResource.mid.replace(/waitingForPlugin$/, prid) : (plugin.mid + \"!\" + prid),\n\t\t\t\t\t\tpluginResource = mix(mix({}, pseudoPluginResource), {mid:mid, prid:prid, injected:0});\n\t\t\t\t\tif(!modules[mid] || !modules[mid].injected /*for require.undef*/){\n\t\t\t\t\t\t// create a new (the real) plugin resource and inject it normally now that the plugin is on board\n\t\t\t\t\t\tinjectPlugin(modules[mid] = pluginResource);\n\t\t\t\t\t} // else this was a duplicate request for the same (plugin, rid) for a nondynamic plugin\n\n\t\t\t\t\t// pluginResource is really just a placeholder with the wrong mid (because we couldn't calculate it until the plugin was on board)\n\t\t\t\t\t// mark is as arrived and delete it from modules; the real module was requested above\n\t\t\t\t\tmap[pseudoPluginResource.mid] = modules[mid];\n\t\t\t\t\tsetArrived(pseudoPluginResource);\n\t\t\t\t\tdelete modules[pseudoPluginResource.mid];\n\t\t\t\t});\n\t\t\t\tplugin.loadQ = 0;\n\n\t\t\t\t// step2: replace all references to any placeholder modules with real modules\n\t\t\t\tvar substituteModules = function(module){\n\t\t\t\t\tfor(var replacement, deps = module.deps || [], i = 0; i<deps.length; i++){\n\t\t\t\t\t\treplacement = map[deps[i].mid];\n\t\t\t\t\t\tif(replacement){\n\t\t\t\t\t\t\tdeps[i] = replacement;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor(var p in modules){\n\t\t\t\t\tsubstituteModules(modules[p]);\n\t\t\t\t}\n\t\t\t\tforEach(execQ, substituteModules);\n\t\t\t},\n\n\t\t\tfinishExec = function(module){\n\t\t\t\treq.trace(\"loader-finish-exec\", [module.mid]);\n\t\t\t\tmodule.executed = executed;\n\t\t\t\tmodule.defOrder = defOrder++;\n\t\t\t\t 0  && forEach(module.provides, function(cb){ cb(); });\n\t\t\t\tif(module.loadQ){\n\t\t\t\t\t// the module was a plugin\n\t\t\t\t\tpromoteModuleToPlugin(module);\n\t\t\t\t\tresolvePluginLoadQ(module);\n\t\t\t\t}\n\t\t\t\t// remove all occurrences of this module from the execQ\n\t\t\t\tfor(i = 0; i < execQ.length;){\n\t\t\t\t\tif(execQ[i] === module){\n\t\t\t\t\t\texecQ.splice(i, 1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// delete references to synthetic modules\n\t\t\t\tif (/^require\\*/.test(module.mid)) {\n\t\t\t\t\tdelete modules[module.mid];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcircleTrace = [],\n\n\t\t\texecModule = function(module, strict){\n\t\t\t\t// run the dependency vector, then run the factory for module\n\t\t\t\tif(module.executed === executing){\n\t\t\t\t\treq.trace(\"loader-circular-dependency\", [circleTrace.concat(module.mid).join(\"->\")]);\n\t\t\t\t\treturn (!module.def || strict) ? abortExec :  (module.cjs && module.cjs.exports);\n\t\t\t\t}\n\t\t\t\t// at this point the module is either not executed or fully executed\n\n\n\t\t\t\tif(!module.executed){\n\t\t\t\t\tif(!module.def){\n\t\t\t\t\t\treturn abortExec;\n\t\t\t\t\t}\n\t\t\t\t\tvar mid = module.mid,\n\t\t\t\t\t\tdeps = module.deps || [],\n\t\t\t\t\t\targ, argResult,\n\t\t\t\t\t\targs = [],\n\t\t\t\t\t\ti = 0;\n\n\t\t\t\t\tif( 0 ){\n\t\t\t\t\t\tcircleTrace.push(mid);\n\t\t\t\t\t\treq.trace(\"loader-exec-module\", [\"exec\", circleTrace.length, mid]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// for circular dependencies, assume the first module encountered was executed OK\n\t\t\t\t\t// modules that circularly depend on a module that has not run its factory will get\n\t\t\t\t\t// the pre-made cjs.exports===module.result. They can take a reference to this object and/or\n\t\t\t\t\t// add properties to it. When the module finally runs its factory, the factory can\n\t\t\t\t\t// read/write/replace this object. Notice that so long as the object isn't replaced, any\n\t\t\t\t\t// reference taken earlier while walking the deps list is still valid.\n\t\t\t\t\tmodule.executed = executing;\n\t\t\t\t\twhile((arg = deps[i++])){\n\t\t\t\t\t\targResult = ((arg === cjsRequireModule) ? createRequire(module) :\n\t\t\t\t\t\t\t\t\t\t((arg === cjsExportsModule) ? module.cjs.exports :\n\t\t\t\t\t\t\t\t\t\t\t((arg === cjsModuleModule) ? module.cjs :\n\t\t\t\t\t\t\t\t\t\t\t\texecModule(arg, strict))));\n\t\t\t\t\t\tif(argResult === abortExec){\n\t\t\t\t\t\t\tmodule.executed = 0;\n\t\t\t\t\t\t\treq.trace(\"loader-exec-module\", [\"abort\", mid]);\n\t\t\t\t\t\t\t 0  && circleTrace.pop();\n\t\t\t\t\t\t\treturn abortExec;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs.push(argResult);\n\t\t\t\t\t}\n\t\t\t\t\trunFactory(module, args);\n\t\t\t\t\tfinishExec(module);\n\t\t\t\t\t 0  && circleTrace.pop();\n\t\t\t\t}\n\t\t\t\t// at this point the module is guaranteed fully executed\n\n\t\t\t\treturn module.result;\n\t\t\t},\n\n\n\t\t\tcheckCompleteGuard = 0,\n\n\t\t\tguardCheckComplete = function(proc){\n\t\t\t\ttry{\n\t\t\t\t\tcheckCompleteGuard++;\n\t\t\t\t\tproc();\n\t\t\t\t}catch(e){\n\t\t\t\t\t// https://bugs.dojotoolkit.org/ticket/16617\n\t\t\t\t\tthrow e;\n\t\t\t\t}finally{\n\t\t\t\t\tcheckCompleteGuard--;\n\t\t\t\t}\n\t\t\t\tif(execComplete()){\n\t\t\t\t\tsignal(\"idle\", []);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcheckComplete = function(){\n\t\t\t\t// keep going through the execQ as long as at least one factory is executed\n\t\t\t\t// plugins, recursion, cached modules all make for many execution path possibilities\n\t\t\t\tif(checkCompleteGuard){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\tcheckDojoRequirePlugin();\n\t\t\t\t\tfor(var currentDefOrder, module, i = 0; i < execQ.length;){\n\t\t\t\t\t\tcurrentDefOrder = defOrder;\n\t\t\t\t\t\tmodule = execQ[i];\n\t\t\t\t\t\texecModule(module);\n\t\t\t\t\t\tif(currentDefOrder!=defOrder){\n\t\t\t\t\t\t\t// defOrder was bumped one or more times indicating something was executed (note, this indicates\n\t\t\t\t\t\t\t// the execQ was modified, maybe a lot (for example a later module causes an earlier module to execute)\n\t\t\t\t\t\t\tcheckDojoRequirePlugin();\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// nothing happened; check the next module in the exec queue\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t}\n\n\tvar fixupUrl= typeof userConfig.fixupUrl == \"function\" ? userConfig.fixupUrl : function(url){\n\t\t\turl += \"\"; // make sure url is a Javascript string (some paths may be a Java string)\n\t\t\treturn url + (cacheBust ? ((/\\?/.test(url) ? \"&\" : \"?\") + cacheBust) : \"\");\n\t\t};\n\n\n\n\tif( 0 ){\n\t\treq.undef = function(moduleId, referenceModule){\n\t\t\t// In order to reload a module, it must be undefined (this routine) and then re-requested.\n\t\t\t// This is useful for testing frameworks (at least).\n\t\t\tvar module = getModule(moduleId, referenceModule);\n\t\t\tsetArrived(module);\n\t\t\tmix(module, {def:0, executed:0, injected:0, node:0, load:0});\n\t\t};\n\t}\n\n\tif( false ){\n\t\tif( 0 ===undefined){\n\t\t\t 0 && has.add(\"dojo-loader-eval-hint-url\", 1);\n\t\t}\n\n\t\tvar injectPlugin = function(\n\t\t\t\tmodule\n\t\t\t){\n\t\t\t\t// injects the plugin module given by module; may have to inject the plugin itself\n\t\t\t\tvar plugin = module.plugin;\n\n\t\t\t\tif(plugin.executed === executed && !plugin.load){\n\t\t\t\t\t// executed the module not knowing it was a plugin\n\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t}\n\n\t\t\t\tvar onLoad = function(def){\n\t\t\t\t\t\tmodule.result = def;\n\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\tfinishExec(module);\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t};\n\n\t\t\t\tif(plugin.load){\n\t\t\t\t\tplugin.load(module.prid, module.req, onLoad);\n\t\t\t\t}else if(plugin.loadQ){\n\t\t\t\t\tplugin.loadQ.push(module);\n\t\t\t\t}else{\n\t\t\t\t\t// the unshift instead of push is important: we don't want plugins to execute as\n\t\t\t\t\t// dependencies of some other module because this may cause circles when the plugin\n\t\t\t\t\t// loadQ is run; also, generally, we want plugins to run early since they may load\n\t\t\t\t\t// several other modules and therefore can potentially unblock many modules\n\t\t\t\t\tplugin.loadQ = [module];\n\t\t\t\t\texecQ.unshift(plugin);\n\t\t\t\t\tinjectModule(plugin);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// for IE, injecting a module may result in a recursive execution if the module is in the cache\n\n\t\t\tcached = 0,\n\n\t\t\tinjectingModule = 0,\n\n\t\t\tinjectingCachedModule = 0,\n\n\t\t\tevalModuleText = function(text, module){\n\t\t\t\t// see def() for the injectingCachedModule bracket; it simply causes a short, safe circuit\n\t\t\t\tif( 0 ){\n\t\t\t\t\ttext = text.replace(/([\"'])use strict\\1/g, '');\n\t\t\t\t}\n\t\t\t\tinjectingCachedModule = 1;\n\t\t\t\tif( 0 ){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tif(text===cached){\n\t\t\t\t\t\t\tcached.call(null);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treq.eval(text,  0  ? module.url : module.mid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tsignal(error, makeError(\"evalModuleThrew\", module));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(text===cached){\n\t\t\t\t\t\tcached.call(null);\n\t\t\t\t\t}else{\n\t\t\t\t\t\treq.eval(text,  0  ? module.url : module.mid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinjectingCachedModule = 0;\n\t\t\t},\n\n\t\t\tinjectModule = function(module){\n\t\t\t\t// Inject the module. In the browser environment, this means appending a script element into\n\t\t\t\t// the document; in other environments, it means loading a file.\n\t\t\t\t//\n\t\t\t\t// If in synchronous mode, then get the module synchronously if it's not xdomainLoading.\n\n\t\t\t\tvar mid = module.mid,\n\t\t\t\t\turl = module.url;\n\t\t\t\tif(module.executed || module.injected || waiting[mid] || (module.url && ((module.pack && waiting[module.url]===module.pack) || waiting[module.url]==1))){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsetRequested(module);\n\n\t\t\t\tif( 0 ){\n\t\t\t\t\tvar viaCombo = 0;\n\t\t\t\t\tif(module.plugin && module.plugin.isCombo){\n\t\t\t\t\t\t// a combo plugin; therefore, must be handled by combo service\n\t\t\t\t\t\t// the prid should have already been converted to a URL (if required by the plugin) during\n\t\t\t\t\t\t// the normalize process; in any event, there is no way for the loader to know how to\n\t\t\t\t\t\t// to the conversion; therefore the third argument is zero\n\t\t\t\t\t\treq.combo.add(module.plugin.mid, module.prid, 0, req);\n\t\t\t\t\t\tviaCombo = 1;\n\t\t\t\t\t}else if(!module.plugin){\n\t\t\t\t\t\tviaCombo = req.combo.add(0, module.mid, module.url, req);\n\t\t\t\t\t}\n\t\t\t\t\tif(viaCombo){\n\t\t\t\t\t\tcomboPending= 1;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(module.plugin){\n\t\t\t\t\tinjectPlugin(module);\n\t\t\t\t\treturn;\n\t\t\t\t} // else a normal module (not a plugin)\n\n\n\t\t\t\tvar onLoadCallback = function(){\n\t\t\t\t\trunDefQ(module);\n\t\t\t\t\tif(module.injected !== arrived){\n\t\t\t\t\t\t// the script that contained the module arrived and has been executed yet\n\t\t\t\t\t\t// nothing was added to the defQ (so it wasn't an AMD module) and the module\n\t\t\t\t\t\t// wasn't marked as arrived by dojo.provide (so it wasn't a v1.6- module);\n\t\t\t\t\t\t// therefore, it must not have been a module; adjust state accordingly\n\t\t\t\t\t\tif( 0 ){\n\t\t\t\t\t\t\tsignal(error, makeError(\"noDefine\", module));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\tmix(module, nonModuleProps);\n\t\t\t\t\t\treq.trace(\"loader-define-nonmodule\", [module.url]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif( 0  && legacyMode){\n\t\t\t\t\t\t// must call checkComplete even in for sync loader because we may be in xdomainLoading mode;\n\t\t\t\t\t\t// but, if xd loading, then don't call checkComplete until out of the current sync traversal\n\t\t\t\t\t\t// in order to preserve order of execution of the dojo.required modules\n\t\t\t\t\t\t!syncExecStack.length && checkComplete();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tcached = cache[mid] || cache[urlKeyPrefix + module.url];\n\t\t\t\tif(cached){\n\t\t\t\t\treq.trace(\"loader-inject\", [\"cache\", module.mid, url]);\n\t\t\t\t\tevalModuleText(cached, module);\n\t\t\t\t\tonLoadCallback();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif( 0  && legacyMode){\n\t\t\t\t\tif(module.isXd){\n\t\t\t\t\t\t// switch to async mode temporarily; if current legacyMode!=sync, then is must be one of {legacyAsync, xd, false}\n\t\t\t\t\t\tlegacyMode==sync && (legacyMode = xd);\n\t\t\t\t\t\t// fall through and load via script injection\n\t\t\t\t\t}else if(module.isAmd && legacyMode!=sync){\n\t\t\t\t\t\t// fall through and load via script injection\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// mode may be sync, xd/legacyAsync, or async; module may be AMD or legacy; but module is always located on the same domain\n\t\t\t\t\t\tvar xhrCallback = function(text){\n\t\t\t\t\t\t\tif(legacyMode==sync){\n\t\t\t\t\t\t\t\t// the top of syncExecStack gives the current synchronously executing module; the loader needs\n\t\t\t\t\t\t\t\t// to know this if it has to switch to async loading in the middle of evaluating a legacy module\n\t\t\t\t\t\t\t\t// this happens when a modules dojo.require's a module that must be loaded async because it's xdomain\n\t\t\t\t\t\t\t\t// (using unshift/shift because there is no back() methods for Javascript arrays)\n\t\t\t\t\t\t\t\tsyncExecStack.unshift(module);\n\t\t\t\t\t\t\t\tevalModuleText(text, module);\n\t\t\t\t\t\t\t\tsyncExecStack.shift();\n\n\t\t\t\t\t\t\t\t// maybe the module was an AMD module\n\t\t\t\t\t\t\t\trunDefQ(module);\n\n\t\t\t\t\t\t\t\t// legacy modules never get to defineModule() => cjs and injected never set; also evaluation implies executing\n\t\t\t\t\t\t\t\tif(!module.cjs){\n\t\t\t\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\t\t\t\tfinishExec(module);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(module.finish){\n\t\t\t\t\t\t\t\t\t// while synchronously evaluating this module, dojo.require was applied referencing a module\n\t\t\t\t\t\t\t\t\t// that had to be loaded async; therefore, the loader stopped answering all dojo.require\n\t\t\t\t\t\t\t\t\t// requests so they could be answered completely in the correct sequence; module.finish gives\n\t\t\t\t\t\t\t\t\t// the list of dojo.requires that must be re-applied once all target modules are available;\n\t\t\t\t\t\t\t\t\t// make a synthetic module to execute the dojo.require's in the correct order\n\n\t\t\t\t\t\t\t\t\t// compute a guaranteed-unique mid for the synthetic finish module; remember the finish vector; remove it from the reference module\n\t\t\t\t\t\t\t\t\t// TODO: can we just leave the module.finish...what's it hurting?\n\t\t\t\t\t\t\t\t\tvar finishMid = mid + \"*finish\",\n\t\t\t\t\t\t\t\t\t\tfinish = module.finish;\n\t\t\t\t\t\t\t\t\tdelete module.finish;\n\n\t\t\t\t\t\t\t\t\tdef(finishMid, [\"dojo\", (\"dojo/require!\" + finish.join(\",\")).replace(/\\./g, \"/\")], function(dojo){\n\t\t\t\t\t\t\t\t\t\tforEach(finish, function(mid){ dojo.require(mid); });\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t// unshift, not push, which causes the current traversal to be reattempted from the top\n\t\t\t\t\t\t\t\t\texecQ.unshift(getModule(finishMid));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tonLoadCallback();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttext = transformToAmd(module, text);\n\t\t\t\t\t\t\t\tif(text){\n\t\t\t\t\t\t\t\t\tevalModuleText(text, module);\n\t\t\t\t\t\t\t\t\tonLoadCallback();\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t// if transformToAmd returned falsy, then the module was already AMD and it can be script-injected\n\t\t\t\t\t\t\t\t\t// do so to improve debugability(even though it means another download...which probably won't happen with a good browser cache)\n\t\t\t\t\t\t\t\t\tinjectingModule = module;\n\t\t\t\t\t\t\t\t\treq.injectUrl(fixupUrl(url), onLoadCallback, module);\n\t\t\t\t\t\t\t\t\tinjectingModule = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treq.trace(\"loader-inject\", [\"xhr\", module.mid, url, legacyMode!=sync]);\n\t\t\t\t\t\tif( 0 ){\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\treq.getText(url, legacyMode!=sync, xhrCallback);\n\t\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t\tsignal(error, makeError(\"xhrInjectFailed\", [module, e]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treq.getText(url, legacyMode!=sync, xhrCallback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} // else async mode or fell through in xdomain loading mode; either way, load by script injection\n\t\t\t\treq.trace(\"loader-inject\", [\"script\", module.mid, url]);\n\t\t\t\tinjectingModule = module;\n\t\t\t\treq.injectUrl(fixupUrl(url), onLoadCallback, module);\n\t\t\t\tinjectingModule = 0;\n\t\t\t},\n\n\t\t\tdefineModule = function(module, deps, def){\n\t\t\t\treq.trace(\"loader-define-module\", [module.mid, deps]);\n\n\t\t\t\tif( 0  && module.plugin && module.plugin.isCombo){\n\t\t\t\t\t// the module is a plugin resource loaded by the combo service\n\t\t\t\t\t// note: check for module.plugin should be enough since normal plugin resources should\n\t\t\t\t\t// not follow this path; module.plugin.isCombo is future-proofing belt and suspenders\n\t\t\t\t\tmodule.result = isFunction(def) ? def() : def;\n\t\t\t\t\tsetArrived(module);\n\t\t\t\t\tfinishExec(module);\n\t\t\t\t\treturn module;\n\t\t\t\t}\n\n\t\t\t\tvar mid = module.mid;\n\t\t\t\tif(module.injected === arrived){\n\t\t\t\t\tsignal(error, makeError(\"multipleDefine\", module));\n\t\t\t\t\treturn module;\n\t\t\t\t}\n\t\t\t\tmix(module, {\n\t\t\t\t\tdeps: deps,\n\t\t\t\t\tdef: def,\n\t\t\t\t\tcjs: {\n\t\t\t\t\t\tid: module.mid,\n\t\t\t\t\t\turi: module.url,\n\t\t\t\t\t\texports: (module.result = {}),\n\t\t\t\t\t\tsetExports: function(exports){\n\t\t\t\t\t\t\tmodule.cjs.exports = exports;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tconfig:function(){\n\t\t\t\t\t\t\treturn module.config;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// resolve deps with respect to this module\n\t\t\t\tfor(var i = 0; deps[i]; i++){\n\t\t\t\t\tdeps[i] = getModule(deps[i], module);\n\t\t\t\t}\n\n\t\t\t\tif( 0  && legacyMode && !waiting[mid]){\n\t\t\t\t\t// the module showed up without being asked for; it was probably in a <script> element\n\t\t\t\t\tinjectDependencies(module);\n\t\t\t\t\texecQ.push(module);\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t\tsetArrived(module);\n\n\t\t\t\tif(!isFunction(def) && !deps.length){\n\t\t\t\t\tmodule.result = def;\n\t\t\t\t\tfinishExec(module);\n\t\t\t\t}\n\n\t\t\t\treturn module;\n\t\t\t},\n\n\t\t\trunDefQ = function(referenceModule, mids){\n\t\t\t\t// defQ is an array of [id, dependencies, factory]\n\t\t\t\t// mids (if any) is a vector of mids given by a combo service\n\t\t\t\tvar definedModules = [],\n\t\t\t\t\tmodule, args;\n\t\t\t\twhile(defQ.length){\n\t\t\t\t\targs = defQ.shift();\n\t\t\t\t\tmids && (args[0]= mids.shift());\n\t\t\t\t\t// explicit define indicates possible multiple modules in a single file; delay injecting dependencies until defQ fully\n\t\t\t\t\t// processed since modules earlier in the queue depend on already-arrived modules that are later in the queue\n\t\t\t\t\t// TODO: what if no args[0] and no referenceModule\n\t\t\t\t\tmodule = (args[0] && getModule(args[0])) || referenceModule;\n\t\t\t\t\tdefinedModules.push([module, args[1], args[2]]);\n\t\t\t\t}\n\t\t\t\tconsumePendingCacheInsert(referenceModule);\n\t\t\t\tforEach(definedModules, function(args){\n\t\t\t\t\tinjectDependencies(defineModule.apply(null, args));\n\t\t\t\t});\n\t\t\t};\n\t}\n\n\tvar timerId = 0,\n\t\tclearTimer = noop,\n\t\tstartTimer = noop;\n\tif( 0 ){\n\t\t// Timer machinery that monitors how long the loader is waiting and signals an error when the timer runs out.\n\t\tclearTimer = function(){\n\t\t\ttimerId && clearTimeout(timerId);\n\t\t\ttimerId = 0;\n\t\t};\n\n\t\tstartTimer = function(){\n\t\t\tclearTimer();\n\t\t\tif(req.waitms){\n\t\t\t\ttimerId = global.setTimeout(function(){\n\t\t\t\t\tclearTimer();\n\t\t\t\t\tsignal(error, makeError(\"timeout\", waiting));\n\t\t\t\t}, req.waitms);\n\t\t\t}\n\t\t};\n\t}\n\n\tif ( 0 ) {\n\t\t// Test for IE's different way of signaling when scripts finish loading.  Note that according to\n\t\t// http://bugs.dojotoolkit.org/ticket/15096#comment:14, IE9 also needs to follow the\n\t\t// IE specific code path even though it has an addEventListener() method.\n\t\t// Unknown if special path needed on IE10+, which also has a document.attachEvent() method.\n\t\t// Should evaluate to false for Opera and Windows 8 apps, even though they document.attachEvent()\n\t\t//  is defined in both those environments.\n\t\t 0 && has.add(\"ie-event-behavior\", doc.attachEvent && typeof Windows === \"undefined\" &&\n\t\t\t(typeof opera === \"undefined\" || opera.toString() != \"[object Opera]\"));\n\t}\n\n\tif( 0  && ( false  ||  1 )){\n\t\tvar domOn = function(node, eventName, ieEventName, handler){\n\t\t\t\t// Add an event listener to a DOM node using the API appropriate for the current browser;\n\t\t\t\t// return a function that will disconnect the listener.\n\t\t\t\tif(! 0 ){\n\t\t\t\t\tnode.addEventListener(eventName, handler, false);\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\tnode.removeEventListener(eventName, handler, false);\n\t\t\t\t\t};\n\t\t\t\t}else{\n\t\t\t\t\tnode.attachEvent(ieEventName, handler);\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\tnode.detachEvent(ieEventName, handler);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t\twindowOnLoadListener = domOn(window, \"load\", \"onload\", function(){\n\t\t\t\treq.pageLoaded = 1;\n\t\t\t\t// https://bugs.dojotoolkit.org/ticket/16248\n\t\t\t\ttry{\n\t\t\t\t\tdoc.readyState!=\"complete\" && (doc.readyState = \"complete\");\n\t\t\t\t}catch(e){\n\t\t\t\t}\n\t\t\t\twindowOnLoadListener();\n\t\t\t});\n\n\t\tif( false ){\n\t\t\t// if the loader is on the page, there must be at least one script element\n\t\t\t// getting its parent and then doing insertBefore solves the \"Operation Aborted\"\n\t\t\t// error in IE from appending to a node that isn't properly closed; see\n\t\t\t// dojo/tests/_base/loader/requirejs/simple-badbase.html for an example\n\t\t\t// don't use scripts with type dojo/... since these may be removed; see #15809\n\t\t\t// prefer to use the insertPoint computed during the config sniff in case a script is removed; see #16958\n\t\t\tvar scripts = doc.getElementsByTagName(\"script\"),\n\t\t\t\ti = 0,\n\t\t\t\tscript;\n\t\t\twhile(!insertPointSibling){\n\t\t\t\tif(!/^dojo/.test((script = scripts[i++]) && script.type)){\n\t\t\t\t\tinsertPointSibling= script;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treq.injectUrl = function(url, callback, owner){\n\t\t\t\t// insert a script element to the insert-point element with src=url;\n\t\t\t\t// apply callback upon detecting the script has loaded.\n\n\t\t\t\tvar node = owner.node = doc.createElement(\"script\"),\n\t\t\t\t\tonLoad = function(e){\n\t\t\t\t\t\te = e || window.event;\n\t\t\t\t\t\tvar node = e.target || e.srcElement;\n\t\t\t\t\t\tif(e.type === \"load\" || /complete|loaded/.test(node.readyState)){\n\t\t\t\t\t\t\tloadDisconnector();\n\t\t\t\t\t\t\terrorDisconnector();\n\t\t\t\t\t\t\tcallback && callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tloadDisconnector = domOn(node, \"load\", \"onreadystatechange\", onLoad),\n\t\t\t\t\terrorDisconnector = domOn(node, \"error\", \"onerror\", function(e){\n\t\t\t\t\t\tloadDisconnector();\n\t\t\t\t\t\terrorDisconnector();\n\t\t\t\t\t\tsignal(error, makeError(\"scriptError: \" + url, [url, e]));\n\t\t\t\t\t});\n\n\t\t\t\tnode.type = \"text/javascript\";\n\t\t\t\tnode.charset = \"utf-8\";\n\t\t\t\tnode.src = url;\n\t\t\t\tinsertPointSibling.parentNode.insertBefore(node, insertPointSibling);\n\t\t\t\treturn node;\n\t\t\t};\n\t\t}\n\t}\n\n\tif( 0 ){\n\t\treq.log = function(){\n\t\t\ttry{\n\t\t\t\tfor(var i = 0; i < arguments.length; i++){\n\t\t\t\t\tconsole.log(arguments[i]);\n\t\t\t\t}\n\t\t\t}catch(e){}\n\t\t};\n\t}else{\n\t\treq.log = noop;\n\t}\n\n\tif( 0 ){\n\t\tvar trace = req.trace = function(\n\t\t\tgroup,\t// the trace group to which this application belongs\n\t\t\targs\t// the contents of the trace\n\t\t){\n\t\t\t///\n\t\t\t// Tracing interface by group.\n\t\t\t//\n\t\t\t// Sends the contents of args to the console iff (req.trace.on && req.trace[group])\n\n\t\t\tif(trace.on && trace.group[group]){\n\t\t\t\tsignal(\"trace\", [group, args]);\n\t\t\t\tfor(var arg, dump = [], text= \"trace:\" + group + (args.length ? (\":\" + args[0]) : \"\"), i= 1; i<args.length;){\n\t\t\t\t\targ = args[i++];\n\t\t\t\t\tif(isString(arg)){\n\t\t\t\t\t\ttext += \", \" + arg;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdump.push(arg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treq.log(text);\n\t\t\t\tdump.length && dump.push(\".\");\n\t\t\t\treq.log.apply(req, dump);\n\t\t\t}\n\t\t};\n\t\tmix(trace, {\n\t\t\ton:1,\n\t\t\tgroup:{},\n\t\t\tset:function(group, value){\n\t\t\t\tif(isString(group)){\n\t\t\t\t\ttrace.group[group]= value;\n\t\t\t\t}else{\n\t\t\t\t\tmix(trace.group, group);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\ttrace.set(mix(mix(mix({}, defaultConfig.trace), userConfig.trace), dojoSniffConfig.trace));\n\t\ton(\"config\", function(config){\n\t\t\tconfig.trace && trace.set(config.trace);\n\t\t});\n\t}else{\n\t\treq.trace = noop;\n\t}\n\tif (! 1 ) {\n\t\tvar def = function(\n\t\t\tmid,\t\t  //(commonjs.moduleId, optional)\n\t\t\tdependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before running factory\n\t\t\tfactory\t\t  //(any)\n\t\t){\n\t\t\t///\n\t\t\t// Advises the loader of a module factory. //Implements http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition.\n\t\t\t///\n\t\t\t//note\n\t\t\t// CommonJS factory scan courtesy of http://requirejs.org\n\n\t\t\tvar arity = arguments.length,\n\t\t\t\tdefaultDeps = [\"require\", \"exports\", \"module\"],\n\t\t\t\t// the predominate signature...\n\t\t\t\targs = [0, mid, dependencies];\n\t\t\tif(arity==1){\n\t\t\t\targs = [0, (isFunction(mid) ? defaultDeps : []), mid];\n\t\t\t}else if(arity==2 && isString(mid)){\n\t\t\t\targs = [mid, (isFunction(dependencies) ? defaultDeps : []), dependencies];\n\t\t\t}else if(arity==3){\n\t\t\t\targs = [mid, dependencies, factory];\n\t\t\t}\n\n\t\t\tif( 0  && args[1]===defaultDeps){\n\t\t\t\targs[2].toString()\n\t\t\t\t\t.replace(/(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg, \"\")\n\t\t\t\t\t.replace(/require\\([\"']([\\w\\!\\-_\\.\\/]+)[\"']\\)/g, function(match, dep){\n\t\t\t\t\targs[1].push(dep);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treq.trace(\"loader-define\", args.slice(0, 2));\n\t\t\tvar targetModule = args[0] && getModule(args[0]),\n\t\t\t\tmodule;\n\t\t\tif(targetModule && !waiting[targetModule.mid]){\n\t\t\t\t// given a mid that hasn't been requested; therefore, defined through means other than injecting\n\t\t\t\t// consequent to a require() or define() application; examples include defining modules on-the-fly\n\t\t\t\t// due to some code path or including a module in a script element. In any case,\n\t\t\t\t// there is no callback waiting to finish processing and nothing to trigger the defQ and the\n\t\t\t\t// dependencies are never requested; therefore, do it here.\n\t\t\t\tinjectDependencies(defineModule(targetModule, args[1], args[2]));\n\t\t\t}else if(! 0  || ! 1  || injectingCachedModule){\n\t\t\t\t// not IE path: anonymous module and therefore must have been injected; therefore, onLoad will fire immediately\n\t\t\t\t// after script finishes being evaluated and the defQ can be run from that callback to detect the module id\n\t\t\t\tdefQ.push(args);\n\t\t\t}else{\n\t\t\t\t// IE path: possibly anonymous module and therefore injected; therefore, cannot depend on 1-to-1,\n\t\t\t\t// in-order exec of onLoad with script eval (since it's IE) and must manually detect here\n\t\t\t\ttargetModule = targetModule || injectingModule;\n\t\t\t\tif(!targetModule){\n\t\t\t\t\tfor(mid in waiting){\n\t\t\t\t\t\tmodule = modules[mid];\n\t\t\t\t\t\tif(module && module.node && module.node.readyState === 'interactive'){\n\t\t\t\t\t\t\ttargetModule = module;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( 0  && !targetModule){\n\t\t\t\t\t\tfor(var i = 0; i<combosPending.length; i++){\n\t\t\t\t\t\t\ttargetModule = combosPending[i];\n\t\t\t\t\t\t\tif(targetModule.node && targetModule.node.readyState === 'interactive'){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttargetModule= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( 0  && isArray(targetModule)){\n\t\t\t\t\tinjectDependencies(defineModule(getModule(targetModule.shift()), args[1], args[2]));\n\t\t\t\t\tif(!targetModule.length){\n\t\t\t\t\t\tcombosPending.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}else if(targetModule){\n\t\t\t\t\tconsumePendingCacheInsert(targetModule);\n\t\t\t\t\tinjectDependencies(defineModule(targetModule, args[1], args[2]));\n\t\t\t\t}else{\n\t\t\t\t\tsignal(error, makeError(\"ieDefineFailed\", args[0]));\n\t\t\t\t}\n\t\t\t\tcheckComplete();\n\t\t\t}\n\t\t};\n\t\tdef.amd = {\n\t\t\tvendor:\"dojotoolkit.org\"\n\t\t};\n\n\t\tif( 0 ){\n\t\t\treq.def = def;\n\t\t}\n\t} else {\n\t\tvar def = noop;\n\t}\n\t// allow config to override default implementation of named functions; this is useful for\n\t// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.\n\t// also useful for testing and monkey patching loader\n\tmix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);\n\n\t// now that req is fully initialized and won't change, we can hook it up to the error signal\n\ton(error, function(arg){\n\t\ttry{\n\t\t\tconsole.error(arg);\n\t\t\tif(arg instanceof Error){\n\t\t\t\tfor(var p in arg){\n\t\t\t\t\tconsole.log(p + \":\", arg[p]);\n\t\t\t\t}\n\t\t\t\tconsole.log(\".\");\n\t\t\t}\n\t\t}catch(e){}\n\t});\n\n\t// always publish these\n\tmix(req, {\n\t\tuid:uid,\n\t\tcache:cache,\n\t\tpacks:packs\n\t});\n\n\n\tif( 0 ){\n\t\tmix(req, {\n\t\t\t// these may be interesting to look at when debugging\n\t\t\tpaths:paths,\n\t\t\taliases:aliases,\n\t\t\tmodules:modules,\n\t\t\tlegacyMode:legacyMode,\n\t\t\texecQ:execQ,\n\t\t\tdefQ:defQ,\n\t\t\twaiting:waiting,\n\n\t\t\t// these are used for testing\n\t\t\t// TODO: move testing infrastructure to a different has feature\n\t\t\tpacks:packs,\n\t\t\tmapProgs:mapProgs,\n\t\t\tpathsMapProg:pathsMapProg,\n\t\t\tlistenerQueues:listenerQueues,\n\n\t\t\t// these are used by the builder (at least)\n\t\t\tcomputeMapProg:computeMapProg,\n\t\t\tcomputeAliases:computeAliases,\n\t\t\trunMapProg:runMapProg,\n\t\t\tcompactPath:compactPath,\n\t\t\tgetModuleInfo:getModuleInfo_\n\t\t});\n\t}\n\n\t// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are\n\t// *required* to define (as opposed to require, which is optional)\n\tif(global.define){\n\t\tif( 0 ){\n\t\t\tsignal(error, makeError(\"defineAlreadyDefined\", 0));\n\t\t}\n\t\treturn;\n\t}else{\n\t\tglobal.define = def;\n\t\tglobal.require = req;\n\t\tif( 0 ){\n\t\t\trequire = req;\n\t\t}\n\t}\n\n\tif( 0  && req.combo && req.combo.plugins){\n\t\tvar plugins = req.combo.plugins,\n\t\t\tpluginName;\n\t\tfor(pluginName in plugins){\n\t\t\tmix(mix(getModule(pluginName), plugins[pluginName]), {isCombo:1, executed:\"executed\", load:1});\n\t\t}\n\t}\n\n\tif( 1  && ! 1 ){\n\t\tforEach(delayedModuleConfig, function(c){ config(c); });\n\t\tvar bootDeps = dojoSniffConfig.deps ||\tuserConfig.deps || defaultConfig.deps,\n\t\t\tbootCallback = dojoSniffConfig.callback || userConfig.callback || defaultConfig.callback;\n\t\treq.boot = (bootDeps || bootCallback) ? [bootDeps || [], bootCallback] : 0;\n\t}\n\tif(! 1 ){\n\t\t!req.async && req([\"dojo\"]);\n\t\treq.boot && req.apply(null, req.boot);\n\t}\n})\n.call(this, userConfig, defaultConfig);};"],"sourceRoot":"webpack:///"}